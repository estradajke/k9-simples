\input texinfo
@setfilename k9.info
@settitle Shakti (k9) tutorial
@codequotebacktick on

@copying
@today{}

Copyright @copyright{} 2020 John Estrada
@end copying

@titlepage
@title Shakti tutorial
@author John Estrada
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c @ifnottex
@node Top
@top k9: Manual
This manual is for Shakti (k9) build 2020.12.04.@*

The Shakti programming language is the work of Arthur Whitney and the team at Shakti.  The language comes from a lineage of similar languages going back to APL.  It's also known as k9 given the similarities to k, k2, ..., k6, k7 and the fact that Arthur also wrote those.  k9 is still under development so expect a bit of syntax change and likely even more improvements.

Learning k9 means code like @code{@{x@@(!#x)+\!#y@}} is clear and actually prefered to something much longer and verbose.  You'll have to go a bit down the rabbit hole before it starts to come together but once it does you'll probably be happy you gave it a chance and end up learning a few things.  You'll understand how fast k9 can be in processing and analyzing data and how terse code is less likely to contain errors.  Unfortunately you will be less likely to be content using more bloated and slow frameworks.  

Alas this manual is not as elegant as the k9 language in that the text version of this document is almost as big as the binary of the language.  

The built-in reference screen (@code{\}) containing all the k9 commands.

@include k.d2

@menu
* Introduction:: An introduction to shakti/k9, a novel computer language for data analysis
* Verb:: Elementary functions
* Adverb:: Function modifiers
* Noun:: Basic data types
* List:: Uniform and non-uniform lists
* Dictionary:: Dictionaries and functions for dictionaries
* User Functions:: User-defined functions
* Expression:: Expression Evaluation
* Named Functions:: Named functions
* Knit Functions:: Function to modify lists and dictionaries
* I/O:: Input and output
* Tables:: Tables to store data
* kSQL:: kSQL to query tables
* System:: System functions and measurements
* Control Flow:: If/Do/While Statements 
* Temporal Functions:: Functions for date and time
* Errors:: Error messages
* Examples:: A Short Finance Example + Practice Decomposing Other People's Code
* Benchmark:: Learn how fast this language is
* Conclusion:: Conclusion
@c * Index:: Complete index
@end menu

@node Introduction
@chapter Introduction
@c @cindex chapter, first
The k9 programming language is designed primarily for the analysis of data.  It may surprise new users with two rather different paradigms, (1) fast data analysis and (2) concise syntax.  After you become familiar with the languages, these features will both seem normal and going back to slow and verbose programming will be surprisingly difficult.

@section Going fast
Imagine you have a small, on-disk, 100 million row database containing a time-series with two float values at each time.  Additionally this data could be split in three different tables covering different measurements.  Here's how fast k9 can read in the data from disk and compute a statistic, average difference over each table, which uses each and every row.

@example
 bash-3.2$ ./k
 2020.xx.xx 17GB 4core (c) shakti
 \t q:2:`q;@{select s:avg a-b from x@}'q[!q]
495
@end example

That's 495 ms to read the data in from disk and compute over all the 100 million values.  The data read is the biggest bit.  If the data were already in memory then the computation would be  faster:

@example
 \t @{select s:avg a-b from x@}'q[!q]
230
@end example

230 ms, not bad for 100 million calculations.

The code to generate the on-disk database is presented below.  Speed of course will depend on your hardware so times will vary.

@example
nf:d+*|d:(|-d),d:683 954 997 1000;
T:^`t rand[;_8.64e7]@@
B:100++\1e-2*-3+nf bin/:rand[;*|nf]@@
S:rand[;1e-2*2,2,8#1]@@
L:@{select t,b,a:b+s from +`t`b`s!(T;B;S)@@'x@}
q:`eurusd`usdjpy`usdchf!L'60e6 20e6 20e6
`q 2:q
@end example

@section Going concise

The k9 language is more closely related to mathematics syntax than most programming lanauges.  It requires the developer to learn to ``speak'' k9 but once that happens most find an ability to speak quicker and more accurately in k9 than in other languages.  At this point an example might help.

In mathematics, ``3+2'' is read as ``3 plus 2'' as you learn at an early age that ``+'' is the ``plus'' sign.  For trival operations like arithmetic most programming languages use symbols also.  When moving beyond arithmetic, most programming lanauges switch to words while k9 remains with symbols.  As an example, to determine the distinct values of a list most programming languages might use a syntax like @code{distinct()} while k9 uses @code{?}.  This requires the developer to learn how to say a number of symbols but once that happens it results in much shorter code that is quicker to write, easier to inspect, and easier to maintain.  

This should not be surprising. In arithmetic, which do you find easier to answer?@*@*
Math with text@*
Three plus two times open parenthesis six plus fourteen close parenthesis@*@*
Math with symbols@*
3+2*(6+14)@*

In code, which will you eventually find easier to understand?@*@*
Code with text@*
x = (0,12,3,4,1,17,-5,0,3,11);y=5;@*
distinct_x = distinct(x);@*
gt_distinct_x = [i for i in j if i >= y];@*@*
Code with symbols@*
x:(0,12,3,4,1,17,-5,0,3,11);y:5;@*
z@@&y<z:?x@*

If you're new to k9 then you'll  appreciate that symbols are shorter but look like line noise.  That's true but so did arithetic until you learned the basics.

When you first learned arithmetic you likely didn't have a choice.  Now you have a choice whether or not you want to learn k9.  If you give it a try, then  you'll get it quickly and move onto the power phase fast enough that you'll be happy you gave it a chance.

@section Get k9.

@url{https://shakti.sh}

You will find the Linux version in the linux directory and the MacOS version under macos.  Once you download the MacOS version you'll have to change its file permissions to allow it to execute.

@example
@ chomd u+x k
@end example

Again on the mac if you then attempt to run this file you likely won't succeed due to MacOS security.  You'll need to go to ``System Preferences...'' and then ``Security and Privacy'' and select to allow this binary to run.  (You'll have to have tried and failed to have it appear here automatically.)

@section Help / Info Card
Typing @code{\} in a terminal window gives you a concise overview of the language.  This document aims to provide details to beginning user where the help screen is a bit too terse.  Some commands are not yet complete and thus marked with an asterisk, eg. *update A by B from T where C.

@smallformat
@group
@verbatiminclude k.d
@end group
@end smallformat
@c @page

@section rlwrap
Although you only need the @file{k} binary to run k9 most will also install rlwrap, if not already installed, in order to get command history in a terminal window.  rlwrap is ``Readline wrapper: adds readline support to tools that lack it'' and allows one to arrow up to go through the command buffer history.

In order to start k9 you should either run @file{k} or @file{rlwrap k} to get started.  Here I will show both options but one should run as desired.  In this document lines with input are shown with a leading space and output will be without.  In the examples below the user starts a terminal window in the directory with the @file{k} binary file.  Then the users enters @kbd{rlwrap ./k @key{RET}}.  k9 starts and displays the date of the build, (c), and shakti and then listens to user input.  In this example I have entered the command to exit k9, @kbd{\\}.  Then I start k9 again without rlwrap and again exit the session.

@example
 rlwrap ./k
Sep 13 2020 16GB (c) shakti
 \\

 ./k
Sep 13 2020 16GB (c) shakti
 \\
@end example

@section Simple example

@c JOHN: I SUGGEST MOVING THIS TO LATER BECAUSE AS IT IS, IT WOULDN'T LOOK SIMPLE AT ALL TO A NEWBIE.

Here I will start up k9, perform some trivial calculations, and then close the session.  After this example it will be assumed the user will have a k9 session running and working in repl mode.  Comments (@code{/}) will be added to the end of lines as needed.  One can review @ref{plus}, @ref{enum}, @ref{floor} and @ref{timing} as needed. 

@example
 1+2  / add 1 and 2
3

 !5   / generate a list of 5 integers from 0 to 4
0 1 2 3 4

 1+!5 / add one to each element of the list
1 2 3 4 5

 !_100e6;     / generate a list of 100 million integers (suppress output with ;)
 1+!_100e6;   / do 100 million sums
 \t 1+!_100e6 / time the operations in milliseconds
82
@end example

Now let's exit the session.

@example
 \\
bash-3.2$ 
@end example

@c @example
@c  rlwrap ./k
@c Sep 13 2020 16GB (c) shakti
@c @ n:10000                     / n data points
@c @ s:`a`b`c                    / data for symbols a, b, and c
@c @ q:+s!(-1+n?3;-1+n?3;-1+n?3) / table of returns (-1,0,1) for each symbol
@c @ q                           / print out the table
@c a  b  c 
@c -- -- --
@c  0  1  1
@c -1 -1  0
@c -1  1  1
@c  0  1 -1
@c -1 -1 -1
@c ..
@c @end example
@c 
@c At this point you might want to check which symbol has the highest return, most variance, or any other analysis on the data.
@c 
@c @example
@c @ #'=+(+q)[]                  / count each unique a/b/c combination
@c a  b  c |   
@c -- -- --|---
@c  0  1  1|407
@c -1 -1 -1|379
@c -1  0  0|367
@c  0 -1 -1|391
@c  1  1  1|349
@c ..
@c @ +-1#+\q                     / calculate the return of each symbol
@c a|-68
@c b|117
@c c|73
@c  @{(+/m*m:x-avg x)%#x@}'+q  / calculate the variance of each symbol
@c a|0.6601538
@c b|0.6629631
@c c|0.6708467
@c @end example
@c 

@section Document formatting for code examples
This document uses a number of examples to familiarize the reader with k9.  The sytax is to have input with a leading space and output without a leading space.  This follows the terminal syntax where the REPL input has space but prints output without.
@example
 3+2 / this is input
5    / this is output
@end example

@section k9 Idiosyncracies
One will need to understand some basic rules of k9 in order to progress.  These may seem strange at first but the faster you learn them, the faster you'll move forward. Also, some of them, like overloading based on number of arguments, add a lot of expressability to the language.

@subsection The language changes often (for now).
There may be examples in this document which work on the version indicated but do not with the version currently available to download.  If so, then feel free to drop the author a note.  Items which currently cause an error but are likely to come back 'soon' will be left in the document.

@subsection Colon (@code{:}) is used to set a variable to a value
@code{a:3} is used to set the variable, a, to the value, 3.  @code{a=3} is an equality test to determine if a is equal to 3.

@subsection Percent (@code{%}) is used to divide numbers
Yeah, 2 divided by 5 is written as @code{2%5}, not @code{2/5}.

@subsection Evaluation is done right to left
2+5*3 is 17 and 2*5+3 is 16.  2+5*3 is first evaluated on the right most portion, 5*3, and once that is computed then it proceeds with 2+15.  2*5+3 goes to 2*8 which becomes 16.

@subsection There is no arithmetic order
+ has equal precedence as *.  The order of evaluation is done right to left unless parenthesis are used.  (2+5)*3 = 21 as the 2+5 in parenthesis is done before being multiplied by 3.

@subsection Operators are overloaded depending on the number of arguments.
@example
@ *(13;6;9)    / single argument: * returns the first element
13
@ 2*(13;6;9)   / two arguments: * is multiplication
26 12 18
@end example

@subsection Lists and functions are very similar.
k9 syntax encourages you to treat lists and functions in a similar function.  They should both be thought of a mapping from a value to another value or from a domain to a range. Lists and functions do not have the same type.

@example
 l:3 4 7 12
 f:@{3+x*x@}
 l@@2
7
 f@@2
7
 @@l
`I
 @@f
`.
@end example

@subsection k9 notions of Noun, Verb, and Adverb
k9 uses an analogy with grammar to describe language syntax.  The k9 grammar consists of nouns (data), verbs (functions) and adverbs (function modifiers).
@itemize
@item @t{The boy ate an appple. (Noun verb noun)}
@item @t{The girl ate each olive. (Noun verb adverb noun)}
@end itemize
In k9 as the Help/Info card shows data are nouns, functions/lists are verbs and modifiers are adverbs.
@itemize
@item @t{3 > 2 (Noun verb noun)}
@item @t{3 >' (1 12;1 4 5) (Noun verb adverb noun)}
@end itemize
@page


@node Verb
@chapter Verbs
This chapter covers verbs which are the core primitives of k9.  Given how different is it to call functions in k9 than in most other languages, you may have to read this chapter  a few times.  Once you can ``speak'' k9 you'll read @code{|x} better than @code{reverse(x)}.  

Most functions are overloaded and change depending on the number of arguments.  This can confuse new users.  Eg. @code{(1 4)++(2 3;5 6;7 8)} contains the plus symbol once as flip and then for addition.  (Remember evaluation is right to left!)

There are verbs that can take a function argument. Those are listed with a '[f]' prefix.  These include [nf]cut, [f]take, [f]drop, [sf]find, [sf]at, and [f]apply.

@example
Verb
: @ref{x},         @ref{set}.
+ @ref{flip},      @ref{plus}.
- @ref{negate},    @ref{minus}.
* @ref{first},     @ref{times}.
%            @ref{divide}.
& @ref{where},     @ref{min/and}.
| @ref{reverse},   @ref{max/or}.
< @ref{asc},       @ref{less}.
> @ref{asc,desc},      @ref{less,more}.
= @ref{group},     @ref{equal}.
~ @ref{not},       @ref{match}.
! @ref{enum},      @ref{key}.
, @ref{list},      @ref{cat}.
^ @ref{sort},  [nf]@ref{cut}. 
# @ref{count},  [f]@ref{take}.  
_ @ref{floor},  [f]@ref{drop}.    
$ @ref{string},    @ref{parse}.    
? @ref{unique},[sf]@ref{find}.    
@@ @ref{type},  [sf]@ref{at}.    
. @ref{value},  [f]@ref{apply}.

@end example

@anchor{x}@section x @result{} :x
@c @anchor{parse}@section parse @result{} :x
@c Parse allows one to see how a command is parsed into normal k9 form.  One can value the parse by using the value command, @xref{value}.
@c @example
@c @ :3+2
@c +
@c 3
@c 2
@c @ t:+`a`b!(1 2;3 4)
@c @ :select from t
@c t
@c @ :select a from t
@c t
@c [..]
@c @ p::select a from t  / store output into p
@c @ #p
@c 2
@c @ p 0
@c `t
@c @ p 1
@c a|a
@c @ . p                 / value parse expression
@c a
@c -
@c 1
@c 2
@c @ .(`t;`a!`a)         / value expression
@c a
@c -
@c 1
@c 2
@c @ select from t       / orginal statement
@c a
@c -
@c 1
@c 2
@c @end example
@c Now for an example with a group clause.
@c @example
@c @ t:+`a`b`c!(`x`y`x;0 2 10;1 1 0)
@c @ select avg:+/b%#b by a from t
@c a|avg
@c -|---
@c x|5
@c y|2
@c @ p::select avg:+/b%#b by a from t
@c @ .(#;`t;();`a!`a;`avg!(%;(+/;`b);#`b)) / parse form
@c @ #[t;();`a!`a;`avg!(%;(+/;`b);#`b)]    / functional form
@c a|avg
@c -|---
@c x|10 
@c y|2  
@c @ p::select avg:+/b%#b by a from t where c=1
@c @ #[t;(=;`c;1);`a!`a;`avg!(%;(+/;`b);#`b)]
@c a|avg
@c -|---
@c x|0  
@c y|2  
@c @end example
@c In the example above the parse output is reduced.  In order to see the elements in the output one could manually return the values in the list, eg. p[2;0 1 2].

@anchor{set}@section set @result{} x:y
Set a variable, x, to a value, y.  There should be no space between @code{x} and @code{:}. 

@example
@ a:3
@ a
3
@ b:(`green;37;"blue")
@ b
green
37
blue
@ c:@{x+y@}
@ c
@{x+y@}
@ c[12;15]
27
@end example

@anchor{flip}@section flip @result{} +x
Flip, or transpose, x.  

@example
@ x:((1 2);(3 4);(5 6))
@ x
1 2
3 4
5 6
@ +x
1 3 5
2 4 6
@ `a`b!+x
a|1 3 5
b|2 4 5
@ +`a`b!+x
a b
- -
1 2
3 4
5 6
@end example

@anchor{plus}@section plus @result{} x+y
Add x and y.  Arguments can be elements or lists but if both x and y are lists then they must be of equal length.

@example
 3+7
10

a:3;
 a+8
11

 3+4 5 6 7
7 8 9 10

3 4 5+4 5 6
7 9 11

 3 4+1 2 3        / lengths don't match
:length

@ 10:00+1         / add a minute
10:01

@ 10:00:00+1      / add a second
10:00:01

@ 10:00:00.000+1  / add a millisecond
10:00:00.001
@end example

@anchor{negate}@section negate @result{} -x.

@example
@ -3
-3
@ --3
3
@ x:4;
@ -x
-4
@ d:`a`b!((1 2 3);(4 5 6))
@ -d
a|-1 -2 -3
b|-4 -5 -6
@end example

@anchor{minus}@section minus @result{} x-y.
Subtract y from x.

@example
@ 5-2
3
@ x:4;y:1;
@ x-y
3
@end example

@anchor{first}@section first @result{} *x
Return the first value of x.  
@example
 *1 2 3
1
 *((1 2);(3 4);(5 6))
1 2
 **((1 2);(3 4);(5 6))
1
 *`a`b!((1 2 3);(4 5 6))
1 2 3
 *|1 2 3
3
@end example

@anchor{times}@section times @result{}  x*y
Mutliply x and y.
@example
@ 3*4
12
@ 3*4 5 6
12 15 18
@ 1 2 3*4 5 6
4 10 18
@end example

@anchor{divide}@section divide @result{} x%y
Divide x by y.
@example
@ 12%5
2.4
@ 6%2    / division of two integers returns a float
3f
@end example

@anchor{where}@section where @result{} &x
Given a list of boolean values return the indices where the value is non-zero.   

@example
 &001001b
2 5
 "banana"="a"
010101b
 &"banana"="a"
1 3 5
 x@@&30<x:12.7 0.1 35.6 -12.1 101.101  / return values greater than 30
35.6 101.101
@end example

Given a list of non-negative integer values, eg. x[0], x[1], ..., x[n-1], generate x[0] values of 0,
x[1] values of 1, ..., and x[n-1] values of n-1. 

@example
 & 3 1 0 2
0 0 0 1 3 3

@end example

@anchor{min/and}@section and @result{} x&y
The smaller of x and y.  One can use the over adverb to determine the min value in a list.
@example
@ 3&2
2
@ 1 2 3&4 5 6
1 2 3
@ 010010b&111000b
010000
@ `a&`b
`a
@ &/ 3 2 10 -200 47
-200
@end example

@anchor{reverse}@section reverse @result{} |x
Reverse the list x.
@example
@ |0 3 1 2
2 1 3 0
@ |"banana"
"ananab"
@ |((1 2 3);4;(5 6))
5 6  
4    
1 2 3
@end example

To get the last element, one can take  the first element of the reverse list (*|@math{`}a@math{`}b@math{`}c).

@anchor{max/or}@section or @result{} x|y
The greater of x and y.  Max of a list can be determine by use of the adverb over.
@example
@ 3|2
3
@ 1 2 3|4 5 6
4 5 6
@ 101101b|000111b
101111b
@ |/12 2 3 10 / use over to determine the max of a list
12
@end example

@anchor{asc}@anchor{desc}@section asc(desc) @result{} < (>) x
Sort a list or dictionary in ascending (<) or descending (>) order.  Applied to a list, these will return the indices to be used to achieve the sort.

@example
 <5 7 0 12
2 0 1 3

 x@@<x:5 7 0 12
0 5 7 12

 d:`a`b`c!3 2 1;d
a|3
b|2
c|1

 <d / a dictionary is sorted by value
c|1
b|2
a|3
@end example

@anchor{less}@anchor{more}@section less (more) @result{} x < (>) y
Return true (1b) if x is less (more) than y else false (0b).
@example
@ 3<2
0b
@ 2<3
1b
@ 1 2 3<4 5 6
111b
@ ((1 2 3);4;(5 6))<((101 0 5);12;(10 0)) / size needs to match
101
1  
10
@ "a"<"b"
1b
@end example

@anchor{group}@section group @result{} =x
A dictionary of the distinct values of x (key) and their indices (values).
@example
@ ="banana"
a|1 3 5
b|0    
n|2 4  
@ =0 1 0 2 10 7 0 1 12
 0|0 2 6
 1|1 7  
 2|3    
 7|5    
10|4    
12|8    
@end example

@anchor{equal}@section equal @result{} x=y
Return true (1b) if x is equal to y else false (0b).  

@example
 2=2
1b
 2=3
0b
 2=2.
1b
 "banana"="abnaoo" / check strings of equal length by character
001100b
 "banana"="apple"  / unequal length strings error
^
:length
@end example

@anchor{not}@section not @result{} ~x
Boolean invert of x
@example
@ ~1b
0b
@ ~101b
010b
@ ~37 0 12
010b
@end example

@anchor{match}@section match @result{} x~y
Return true (1b) if x matches y else false (0b).  A match happens if the two arguments evaluate to the same expression.

@example
 2~2
1b
 2~3
0b
 2~2.
0b
 "banana"~"apple"
0b
 `a`b~`a`b  / different than = which is element-wise comparison
1b
 `a`b=`a`b
11b
 f:@{x+y@}
 f~@{x+y@}
1b
@end example

@anchor{enum}@section enum @result{} !x
Enumerate the domain of x.  Given an integer, x, generate an integer list from 0 to x-1.  Given a dictionary, x, return all key values.  

@example
 !3
0 1 2

 !`a`b`c!3 2 1
`a`b`c
@end example

In the case where x is a list of integers  x1 x2 ... xk, generate a matrix of k rows where each row has size */x1 x2 ... xk and the elements of row i are !xi repeated as many times as necessary. Each row's repeats must fit below constant values of the row above.

@example
 / Each row of length 2*3*2 = */2 3 2 = 12.
 / First row values 0,1
 / Second row values 0,1,2
 / Third row values 0,1
 !2 3 2 
0 0 0 0 0 0 1 1 1 1 1 1
0 0 1 1 2 2 0 0 1 1 2 2
0 1 0 1 0 1 0 1 0 1 0 1

 !4 2 3
0 0 0 0 0 0 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3
0 0 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1
0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

 !2 2 2
0 0 0 0 1 1 1 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1

 +!2 2 2
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1
@c 
@c  B:`b'+!16#2 / create a list of all 16-bit binary numbers from 0 to 65535 @c JOHN: THIS DOESN'T WORK
@c 
@c B[12123]    / pull the element 12,123
@c 0010111101011011b
@c 
@c 2/B[12123] / convert to base10 to check it's actually 12123
@c 12123
@end example

@anchor{key}@section key @result{} x!y
Dictionary of x (key) and y (value).  

@example
@ 3!7
,3!,7
@ `a`b!3 7
a|3
b|7
@ `a`b!((1 2);(3 4))
a|1 2
b|3 4
@end example

@anchor{list}@section list @result{} ,x
Create a list from x

@example
@ ,3
,3
@ ,1 2 3
1 2 3
@ 3=,3
,1b
@ 3~,3
0b
@end example

@anchor{cat}@section cat @result{} x,y
Concatenate x and y.
@example
@ 3,7
3 7
@ "hello"," ","there"
"hello there"
@end example

@anchor{sort}@section sort @result{} ^x
Sort list, dictionary, or table x into ascending order.  Dictionaries are sorted using the keys and tables by the first column field.  One can sort tables by arbitrary columns by first reordering the columns in the table using @ref{take} or by extracting the sort column by index or expression.

@example
 ^0 3 2 1
0 1 2 3

^`b`a!((0 1 2);(7 6 5))     / sort dictionary by key
[a:7 6 5;b:0 1 2]

 ^[[]z:`c`a`b;y:3 2 1]      / sort table by 1st col
z y
- -
a 2
b 1
c 3

 ^`y`z#[[]z:`c`a`b;y:3 2 1] / sort table by new 1st col
y z
- -
1 b
2 a
3 c
@end example

@anchor{cut}@section [nf]cut @result{} x^y
Cut list y by size, indices, or function x.  

@flushleft
@multitable {@b{some text for column one}} {for column two}
@item @b{action} @tab @b{x} 
@item @ref{cut1,rows} @tab positive int
@item @ref{cut2,columns} @tab negative int
@item @ref{cut3,indices} @tab list
@item @ref{cut4,function} @tab function
@end multitable
@end flushleft

@anchor{cut1}Positve integer x, cut y into x rows
@example
 3^101+!20   / 3 rows
101 102 103 104 105 106
107 108 109 110 111 112
113 114 115 116 117 118
@end example

@anchor{cut2}Negative integer, cut y into x elements per row
@example
 -3^101+!20  / 3 elements in each row
101 102 103
104 105 106
107 108 109
110 111 112
113 114 115
116 117 118
@end example

@anchor{cut3}Positive integer array x, cut at each element in x
@example
 2 3 7 ^!17  / left list indicates start number of each row.
,2                        
3 4 5 6                   
7 8 9 10 11 12 13 14 15 16

 8 9 10 11 12^.1*!20
,0.8                           
,0.9                           
,1.                            
,1.1                           
1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9
@end example

@anchor{cut4}Function returning boolean array, cut at each index where f is non-zero.
@example
 @{(x*x)within .5 1.5@}^.1*!20
0.8                            
0.9                            
1.                             
1.1                            
1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9
@end example

@c Cut into domain and range, aka key a table (set an attribute to be a key)
@c @example
@c  t:[[]a:`x`y`z;b:1 20 1];t / an unkeyed table
@c a b 
@c - --
@c x  1
@c y 20
@c z  1
@c 
@c  kt:`a^t;kt                / set `a as the key
@c a|b 
@c -|--
@c x| 1
@c y|20
@c z| 1
@c 
@c  (0#`)^kt                  / unkey the keyed table
@c a b 
@c - --
@c x  1
@c y 20
@c z  1
@c @end example 
@c 
@anchor{count}@section count @result{} #x
Count the number of elements in x.
@example
@ #0 1 2 12
4
@ #((0 1 2);3;(4 5))
3
@ #`a`b!((1 2 3);(4 5 6)) / count the number of keys
2
@end example

@anchor{take}@section [f]take @result{} x#y
[f]take has a number of different actions depending on x.  These include head (take from front of list), tail (take from back of list), common (take common elements), filter (take where function is non-zero), and select (take columns from table).

@flushleft
@multitable {@b{some text for column one}} {for column two}
@item @b{action} @tab @b{x} 
@item @ref{take1,head} @tab positive int
@item @ref{take1,tail} @tab negative int
@item @ref{take2,common} @tab list
@item @ref{take3,filter} @tab function
@item @ref{take4,select} @tab name(s)
@end multitable
@end flushleft

@anchor{take1}
Postive (negative) x returns the first (last) x elements of y.  If abs[x]>count[y] then repeatedly pull from y.

@example
 3#0 1 2 3 4 5          / take first 3 elements of a list
0 1 2

 10 # 17 12 25 / take repeat: take from list and repeat as needed
17 12 25 17 12 25 17 12 25 17

 -3#0 1 2 3 4 5         / take last elements of a list
3 4 5


@end example

@anchor{take2}
If x is a list, then take returns any values common in both x and y. 

@example
 (1 2 3 7 8 9)#(2 8 20) / common
2 8

  (2 4 6 2 6 5 4) # (4 6 7 8 2 4 4 4) / substring of right argument
4 6 2 4 4 4
 
 (4 6 7 8 2 4 4 4) # (2 4 6 2 6 5 4)
2 4 6 2 6 4
@end example

@anchor{take3}
If x is a function, then select the values where the function is non-zero.

@example
 (0.5<)#10 rand 1.           / select values greater than 0.5
0.840732 0.5330717 0.7539563 0.643315 0.6993048f
@end example

@anchor{take4}
If x is a name or list of names, then take the name column or columns from the table.

@example
 t:[[]x:`a`b`c;y:3 1 2;z:"tab"];t
x y z
- - -
a 3 t
b 1 a
c 2 b

 `y#t
y
-
3
1
2

 `z`y#t
z y
- -
t 3
a 1
b 2

 `x`z`y#t
x z y
- - -
a t 3
b a 1
c b 2
@end example

@anchor{floor}@section floor @result{} _x
Return the integer floor of float x.
@example
@ _3.7
3
@end example

@anchor{drop}@section [f]drop @result{} x_y
[f]drop has a number of different actions depending on x.  This include de-head (drop from front of list), de-tail (drop from back of list), uncommon (drop common elements), and filter (drop where function is zero).

@flushleft
@multitable {@b{some text for column one}} {for column two}
@item @b{action} @tab @b{x} 
@item @ref{drop1,dehead} @tab positive int
@item @ref{drop1,detail} @tab negative int
@item @ref{drop2,uncommon} @tab list
@item @ref{drop3,filter} @tab function
@end multitable
@end flushleft

@anchor{drop1}
Postive (negative) x drops the first (last) x elements of y.  

@example
 3_0 1 2 3 4 5          / drop first three
3 4 5

 -2_0 1 2 3 4 5         / drop last three
0 1 2 3
@end example

@anchor{drop2}
If x is a list, then drop returns any values from y not found in x. 

@example
 (1 2 3 7 8 9)_(2 8 20) / uncommon
,20
@end example

@anchor{drop3}
If x is a function, then select values where the function is zero.

@example
 (0.5<)_10 rand 1.           / values less than or equal to 0.5
0.02049699 0.1269226
@end example

@anchor{string}@section string @result{} $x
Cast x to string.
@example
 $`abc
"abc"
 $4.7
"4.7"
@end example

@anchor{parse}@section parse @result{} x$y
Parse string y into type x.

@example
 `i$"23"
23
 `f$"2.3"
2.3
 `t$"12:34:56.789"
12:34:56.789
 `d$"2020.04.20"
2020.04.20
@end example

@anchor{unique}@section unique @result{} ?x
Return the unique values of the list x.  The @code{?} preceeding the return value explicitly shows that the list has no repeated values.

@example
@ ?`f`a`b`c`a`b`d`e`a
?`f`a`b`c`d`e
@ ?"banana"
?"ban"
@end example

@anchor{find}@section [sf]find @result{} x?y
Find the first element of x that matches y otherwise return the end of vector.

@example
 `a`b`a`c`b`a`a?`b
1
@ `a`b`a`c`b`a`a?`d / missing thus return the list length
7
@ 0 1 2 3 4?10
5
@ (1;`a;"blue";7.4)?3
4
@end example

There is also another use of @code{?} where x is a special name, eg. @math{`}js, @math{`}csv, or @math{`}nv.  This is further discussed in the @ref{I/O} section.

@anchor{type}@section type @result{} @@x
Return the data type of x.  Lower-case represents a single element while upper-case represents a list of type indicated.

@example
 @@1
`i
 @@1.2
`f
 @@`a
`s
 @@"a"
`c
 @@2020.04.20
`d
 @@12:34:56.789
`t
 @@(1;1.2;`a;"a";2020.04.20;12:34:56.789)  / type of a list
`L
 @@'(1;1.2;`a;"a";2020.04.20;12:34:56.789) / type of elements of the list
`i`f`s`c`d`t
@end example

@anchor{at}@section [sf]at @result{} x@@y
Given a list x return the value(s) at index(indices) y.  

@example
@ (3 4 7 12)@@2
7
@ `a`b`c@@2
`c
@ ((1 2);3;(4 5 6))@@(0 1)   / values at indices 0 and 1
1 2
3
@end example

If x is a function then determine the function with (at) pararmeter y.

@example
 @{x*x@}@@3
9

 (sin;cos;1*)@@\:0.01
0.009999833 0.99995 0.01
@end example

@anchor{value}@section value @result{} .x
Evaluate a string of valid k code or list of k code.  Can also be used to covert from a string to a numeric, 
temporal or name type.

@example
 ."3+2"
5

 ."20*1+!3"
20 40 60

 .(*;16;3)
48

 n:3;p:+(n rand(+;-;*;%);1+n rand 10;1+n rand 10);p
% 6 3
* 2 7
- 5 5

 .'p
2 
14
0

 ."15"
15

 ."12.7"
12.7

 ."`abc"
`abc
@end example

@anchor{apply}@section [f]apply @result{} x.y
Given list x return the value at list y.  The action of apply depends on the shape of y.
@itemize
@item Index returns the value(s) at x at each index y, i.e. x@@y@@0, x@@y@@1, ..., x@@y@@(n-1).
@item Recursive index returns the value(s) at x[y@@0;y@@1].
@item Recursive index over returns x[y[0;0];y[1]], x[y[0;1];y[1]], ..., x[y[0;n-1];y[1]].
@end itemize

@flushleft
@multitable {recursive index over 123} {def} {ghi} {123 123}
@c @headitem action @tab @@y @tab #y @tab example
@item @b{action} @tab @b{@@y} @tab @b{#y} @tab @b{example}
@item simple index @tab @math{`}I @tab 1 @tab ,2
@item simple indices @tab @math{`}I @tab 1 @tab ,1 3
@item recursive index @tab @math{`}L @tab 1 @tab 0 2
@item recursive index over @tab @math{`}L @tab 2 @tab (0 2;1 3)
@end multitable
@end flushleft

@example
@ (3 4 7 12).,2
7
@ `a`b`c.,2
`c
@ x:(`x00`x01;`x10`x11`x12;`x20;`x30`x31`x32);x
x00 x01    
x10 x11 x12
x20        
x30 x31 x32

@ x . ,1
`x10`x11`x12
@ x . ,0 1 3
x00 x01    
x10 x11 x12
x30 x31 x32

@ x . 3 1
`x31
@ x . (1 3;0 1)
x10 x11
x30 x31
@end example

If x is a function then apply the function to y.

@example
 (+). 3 2
5

 (+;-;*;%).\: 3 2
5  
1  
6  
1.5

 a:@{x+y@};b:@{x*sin y@};a . 3 1
4
 a . 3 1
4
 b . 3 1
2.524413

 (!).(`a`b`c;1 2 3)
a|1
b|2
c|3
@end example

@node Adverb
@chapter Adverbs
This chapter may be one of the most difficult for users new to array langauges but one must master adverbs to exploit the full power of k9.  Nouns and verbs naturally come but adverbs need to be learned so that one can reach for them when needed.

@example
Adverb
f/  @ref{scan,over}  V/ @ref{join}
f\  @ref{scan}  V\ @ref{split}
f'  @ref{each}
f': @ref{eachp}
f/: @ref{eachr} (n;f)/:@ref{cover,over} 
f\: @ref{eachl} (n;f)\:@ref{cscan,scan} 
@end example

Adverbs modify verbs to operative iteratively over nouns.  This previous sentence likely will  make sense only once you understand it so let's jump into an example.  Imagine you have a list of 4 lists.  Using @code{first} you will retrieve the first sub-list.  In order to retrieve the first element of each sub-list you'll have to modify the function @code{first} with a modifier @code{each}.

@example 
x: (1 2; 3 4; 5 6; 7 8)
 *x
1 2
 *'x
1 3 5 7
@end example

@anchor{over}@section over @result{} f/x
Over has the same function as @ref{scan} but returns only the last value.

@anchor{scan}@section scan @result{} f\x
Compute f[x;y] such that f@sub{i}=f[f@sub{i-1};x@sub{i}].

@flushleft
@multitable {i} {i} {i} {i} {i} {i} {i} {i} {i}
@item @b{i} @tab @b{x} @tab @b{f[x]} @tab @b{a f[x]} @tab @b{x:0 1 4 9 16 25} @tab @b{+\x} @tab @b{3+\x} @tab @b{+/x} @tab @b{3+/x}
@item 0 @tab x@sub{0} @tab x@sub{0} @tab f@sub{0}[a;x@sub{0}] @tab 0 @tab 0 @tab 3 @tab @tab
@item 1 @tab x@sub{1} @tab f@sub{1}[f@sub{0};x@sub{1}] @tab f@sub{1}[f@sub{0};x@sub{1}] @tab 1 @tab 1 @tab 4 @tab @tab
@item .. @tab .. @tab .. @tab .. @tab .. @tab .. @tab .. @tab @tab
@item j @tab x@sub{j} @tab f@sub{j}[f@sub{j-1};x@sub{j}] @tab f@sub{j}[f@sub{j-1};x@sub{j}] @tab .. @tab .. @tab .. @tab @tab
@item .. @tab .. @tab .. @tab .. @tab .. @tab .. @tab .. @tab @tab
@item n-2 @tab x@sub{n-2} @tab f@sub{n-2}[f@sub{n-3};x@sub{n-2}] @tab f@sub{n-2}[f@sub{n-3};x@sub{n-2}] @tab 16 @tab 30 @tab 33 @tab @tab
@item n-1 @tab x@sub{n-1} @tab f@sub{n-1}[f@sub{n-2};x@sub{n-1}] @tab f@sub{n-1}[f@sub{n-2};x@sub{n-1}] @tab 25 @tab 55 @tab 58 @tab 55 @tab 58
@end multitable
@end flushleft


An example

@example
 (,\)("a";"b";"c")   / scan and cat to build up a list
a
ab
abc
 +\1 20 300          / scan and plus to sum over a list
1 21 321

 @{y+10*x@}\1 20 300   / scan and user func
1 30 600

 @{y+10*x@}/1 20 300   / over and user func
600
@end example

@anchor{join}@section join @result{} V/x
Join a list of strings x using character V between each pair.

@example
 "-"/("Some";"random text";"plus";,".")
"Some-random text-plus-."
@end example

The notaion V/x converts a list of integers x via base V into base 10. In the example below, assuming 2 0 1 are digits in base 8, they convert to  1 + (0*8) + (2*8*8) = 129

@example
 8/2 0 1  
129
@end example

@anchor{split}@section split @result{} V\x
Split the string x using character V to determine the locations.

@example
 " "\"Here is a short sentence."
Here     
is       
a        
short    
sentence.
@end example

V\x splits a number x into base V digits.

@example
 8\129
2 0 1
@end example

@anchor{each}@section each @result{} f'x
Apply function f to each value in list x in a single thread.  Multithread operation is done with @ref{eachp}.  

@example
@ *((1 2 3);4;(5 6);7)   / first element of the list
1 2 3

@ *'((1 2 3);4;(5 6);7)  / first element of each element
1 4 5 7
@end example

@anchor{eachp}@section eachp @result{} f':[x;y]
Apply f[x;y] using the prior value of y, eg. f[y@@n;y@@n-1].  The first value, n=0, returns f[y@@0;x].

@example
@ ,':[`x;(`$"y",'$!5)]
y0 x 
y1 y0
y2 y1
y3 y2
y4 y3

@ %':[100;100 101.9 105.1 102.3 106.1] / compute returns
1 1.019 1.031403 0.9733587 1.037146

@ 100%':100 101.9 105.1 102.3 106.1    / using infix notation
1 1.019 1.031403 0.9733587 1.037146
@end example

Additionally eachp (':) is a multithreaded (parallel) each.  This will allow a function to run using multiple threads over a list of arguments.

@example
\t @{L:xrand 1.;sum L%sin L*cos L*sin L+L*L@}':8#_50e6 / multiple threads
831

\t @{L:xrand 1.;sum L%sin L*cos L*sin L+L*L@}'8#_50e6  / single thread
1202
@end example

@c @anchor{bin2}@subsection +bin @result{} x':y
@c Given a sorted (increasing) list x, find the greatest index, i, where y>x[i].  
@c 
@c @example
@c @ n:exp 0.01*!5;n
@c 1 1.01005 1.020201 1.030455 1.040811
@c @ n':1.025
@c 2
@c @end example
@c 
@anchor{eachr}@section eachr @result{} f/:x
Apply f[x;y] to each value of y, i.e. the right one.

@example
 (!2)+/:!3
0 1
1 2
2 3

 @{x+10*y@}/:[!2;!3]
0 1  
10 11
20 21
@end example

@anchor{eachl}@section eachl @result{} f\:x
Apply f[x;y] to each value of x, i.e. the left one.

@example
 (!2)+\:!3
0 1 2
1 2 3

 @{x+10*y@}\:[!2;!3]
0 10 20
1 11 21
@end example

@anchor{cover}@subsection Converge Over @result{} f/:x or (n;f)/:x
Converge Over is the same function as @ref{cscan,Converge Scan} but only returns the final value(s).

@anchor{cscan}@subsection Converge Scan @result{} f\:x or (n;f)\:x
Compute f[x] where x is the previous output of f until the value converges or returns to x.  The initial value of x is the input.

If n is specified then it is either the number of iterations or a function returning a boolean.  

@example
  @{x*x@}\:.99       / converge to value
0.99 0.9801 0.9605961 ... 1.323698e-18 1.752177e-36 0.

 (3;@{x*x@})\:.99   / do 3 times, return 4 values (first is initial)
0.99 0.9801 0.960596 0.9227448

 (.5<;@{x*x@})\:.99 / while .5 < r, i.e. r is greater than 0.5
0.99 0.9801 0.960596 0.9227448 0.8514579 0.7249806 0.5255968 0.276252

 x:3 4 2 1 4 99   / until output is x
 x\:0
0 3 1 4

 / the latter example worked out manually
 x 0
3
 x 3
1
 x 1
4
 x 4              / x[4]=4 so will stop
4
@end example

@c 
@c @flushleft
@c @multitable {converge over 123 123 123} {f parameters 123} {element 123} {element/array 123}
@c @item @b{name} @tab @b{f parameters} @tab @b{x} @tab @b{y}
@c @item @ref{cover,converge over} @tab 1 @tab element @tab n/a
@c @item @ref{each right} @tab 2 @tab array @tab element/array
@c @end multitable
@c @end flushleft

@c 
@c @flushleft
@c @multitable {converge scan 123 123} {abc} {abc} {element/array 123}
@c @item @b{name} @tab @b{f parameters} @tab @b{x} @tab @b{y}
@c @item @ref{cscan,converge scan} @tab 1 @tab element @tab n/a
@c @item @ref{each left} @tab 2 @tab array @tab element/array
@c @end multitable
@c @end flushleft

@node Noun
@chapter Noun
The basic data types of the k9 language are booleans, numbers (integer and float), text (characters and enumerated/name) and temporal (date and time).  It is common to have functions operate on multiple data types.

In additional to the basic data types, data can be put into lists (uniform, i.e., all elements of the same type, and non-uniform), dictionaries (key-value pairs), and tables (transposed/flipped dictionaries).  Dictionaries and tables will be covered in anohter chapter.

Here are some examples of each of these types (note that 0N is a null integer and 0n a null float).

@example
type              
@ref{bool} 011b
@ref{int}  0N 0 2 3
@ref{flt}  0n 0 2 3.4   
@ref{char} " ab"        
@ref{name} ``ab         
@ref{uuid}

@ref{date} 2024.01.01
@ref{time} 12:34:56.123456789
@end example

Data types can be determined by using the @code{@@} function on values or lists of values.  In the case of non-uniform lists @code{@@} returns the type of the list @code{`L} but the function can be modified to evaluate the type of each element in the list using @code{@@'}.

@example
@ @@1            / integer atom
`i
@ @@1 2 3        / integer list
`I
@ @@12:34:56.789 / time atom
@ @@(3;3.1;"b";`a;12:01:02.123;2020.04.05) / mixed list
`L
@ @@'(3;3.1;"b";`a;12:01:02.123;2020.04.05)
`i`f`c`n`t`d
@end example

@anchor{Atom Types}@section Atom Types
This section lists all the different types available.  Generally lower case specifies atoms and upper case as lists.

@multitable @columnfractions .1 .15 .45 .4
@item @b{name} @tab @b{type} @tab @b{example} @tab @b{note}
@item @tab @tab
@item b @tab boolean @tab 1b @tab 
@item c @tab character @tab ``a'' @tab
@item d @tab date @tab 2020.06.14 @tab
@item e @tab float @tab 3.1 @tab
@item f @tab float @tab 3.1f @tab
@item g @tab int @tab 2g @tab 1 byte unsigned
@item h @tab int @tab 2h @tab 2 byte unsigned
@item i @tab int @tab 2 @tab 4 byte unsigned
@item j @tab int @tab 2j @tab 8 byte signed
@item n @tab name @tab @math{`}abc @tab 8 char max
@item s @tab time @tab 12:34:56 @tab second
@item S @tab datetime @tab 2020.06.15T12:34:56 @tab second
@item t @tab time @tab 12:34:56.123 @tab millisecond
@item T @tab datetime @tab 2020.06.15T12:34:56.123 @tab millisecond
@item u @tab time @tab 12:34:56.123456 @tab microsecond
@item U @tab datetime @tab 2020.06.15T12:34:56.123456 @tab microsecond
@item v @tab time @tab 12:34:56.123456789 @tab nanosecond
@item V @tab datetime @tab 2020.06.15T12:34:56.123456789 @tab nanosecond
@end multitable


@anchor{bool}@section bool @result{} Boolean b
Booleans have two possible values 0 and 1 and have a 'b' to avoid confusion with integers, eg. 0b or 1b.

@example
@ 0b
0b
@ 1b
1b
@ 10101010b
10101010b
@end example

@subsection boolean logic
k9 implements logic operations in the usual way.

@example
 x:0101b;y:0011b

[[x:x;y:y]AND:x&y;OR:x|y;NAND:~x&y;NOR:~x|y;XOR:~x=y;XNOR:x=y]
x y|AND OR NAND NOR XOR XNOR
- -|--- -- ---- --- --- ----
0 0|  0  0    1   1   0    1
1 0|  0  1    1   0   1    0
0 1|  0  1    1   0   1    0
1 1|  1  1    0   0   0    1
@end example

@section Numeric Data
Numbers can be stored as integers and floats.

@anchor{int}@subsection int @result{} Integer g, h, i, j
Integers can be stored in four different ways which correspond 1, 2, 4, and 8 bytes.  The first three are unsigned and the last (j) is signed.  Positive numbers default to i and negative and very large numbers default to j.  One can specify a non-default type by adding one of the four letters immediately following the number.

@example
 @@37    / will default to i
`i
 @@-37   / negative so will default to j
`j

 @@37g   / cast as g, one byte unsigned
`g

b:@{-1+*/x#256@}
 `g b[1]
255g
 `h b[2]
65535h
 `i b[4]
4294967295
 `j b[7]
72057594037927935
@end example

@anchor{flt}@subsection flt @result{} Float e, f
Float
@example
 3.1
3.1
 3.1+1.2
4.3
 3.1-1.1   
2.
 @@3.1-1.1
`e
 @@3.1
`e
 a:3.1;
 @@a
`e
 @@1%3
`f
@end example

@section Text Data
Text data come in characters, lists of characters (aka strings) and enumerated types.  Enumerated types are displayed as text but stored internally as integers.

@anchor{char}@subsection char @result{} Character c
Characters are stored as their ANSI value and can be seen by conversion to integers.  A string is a list of characters (including blanks).

@example
@ @@"b"
`c
@ @@"bd"
`C 
@end example

@anchor{name}@subsection name @result{} Name n
A name is an enumerated type displayed as a text string but stored internally as an integer value.

@example
@ @@`blue
`n
@ @@`blue`red
`N
@end example

@section Unique Identifier
TBD

@anchor{uuid}@subsection uuid @result{} Uuid
TBD

@section Temporal Data
Temporal data can be expressed as time, date, or a combined date and time.

@anchor{time}@subsection time @result{} Time s, t, u, v
Time has four types depending on the level of precision.  The types are seconds (s), milliseconds (t), microseconds (u), and nanoseconds (v).  The times are all stored internally as integers.  The integers are the number of time units.  For example 00:00:00.012 and 00:00:00.000000012 are both stored as 12 internally.

@example
 @@12:34:56.789             / time
`t
 .z.t                       / current time in GMT (Greenwich Mean Time)
17:32:57.995
 t: .z.t-17:30:00.000; t
00:03:59.986
 t
17:33:59.986
 `i 00:00:00.001            / numeric representation of 1ms
1
 `i 00:00:01.000            / numeric representation of 1s
1000
 `i 00:01:00.000            / numeric representation of 1m
60000
 `t 12345                   / convert number to milliseconds
00:00:12.345
@end example

@anchor{date}@subsection date @result{} Date d
Dates are in yyyy.mm.dd format.  Dates are stored internally as integers with 0 corresponding to 2001.01.01.

@example
 @@2020.04.20               / date
`d
 .z.d                       / current date in GMT
2020.12.05
 `i .z.d                    / numeric representation of date
7278
 `i 2001.01.01              / zero date
0
 `d 0                       / zero date
2001.01.01
@end example

@anchor{datetime}@subsection datetime @result{} Datetime d
Dates and times can be combined into a single datetime element by combining a date, the letter T, and the time together without spaces.  The datetime use the same lettering as the time precision but in uppercase.  Datetimes are stored interally as integers.  For example 2001.01.02T00:00:00.000 is stored as 86,400,000, the number of milliseconds in a day.

@example
 @@2020.04.20T12:34:56.789  / date and time
`d
 `T$"2020.04.20 12:34:56.789" / converting from string
2020.04.20T12:34:56.789
@end example

@section Extreme values
Data types can represent in-range, null, and out-of-range values.

@multitable @columnfractions .15 .15 .2
@c @headitem type @tab null @tab out of range
@item @b{type} @tab @b{null} @tab @b{out of range}
@c@item @tab @tab
@item i @tab 0N @tab 0W
@item f @tab 0n @tab 0w
@end multitable

@example
@ 0%0
0n
@ 1e500
0w
@end example

@node List
@chapter List
Lists and derivatives of lists are fundamental to k9 which makes sense given that the language is made to process large quantites of data.  Performance will be best when working with uniform lists of a single data type but k9 supports list of non-uniform type also.

Lists are automatically formed when a sequence of uniform type are entered or generated by any function.

@example
 1 3 12      / list of ints
1 3 12

 3.1 -4.1 5. / list of floats
3.1 -4.1 5.

 "abc"       / list of chars
"abc"

 `x`y`z      / list of names
`x`y`z
@end example

In order to determine if data is an atom or a list, one can use the @ref{type} command.  The command returns a lower case value for atoms and an upper case value for lists.

@example
 @@1          / an integer
i

@@1 3 12     / list of ints
I

@@,1         / list of single int via @ref{list}
I
@end example

Commands that generate sequences of numbers return lists regardless of whether the count (length of the list) is 1 or many.

@example
 @@!0
`I
 @@!1
`I
 @@!2
`I
@end example

@section List Syntax
In general, lists consist of elements separated by semicolons and encased by parenthesis.

@example
 (1;3;12)         / list of ints
 @@(1;3.;`a;"b")   / non-uniform list
L
 @@((1;3);(12;0))  / list of lists
L
 @@'((1;3);(12;0)) / each list is type I
`I`I
  ,,,,,(3;1)      / a list of a list of a list ...
,,,,,3 1
@end example

@section List Indexing
Lists can be indexed in different ways.  The @@ notation is often used as it's fewer characters than [] and the explicit @@ instead of space is likely more clear.

@example
 a:2*1+!10 / 2 4 ... 20
 a[9]      / square bracket
20
 a@@9       / at
20
 a 9       / space 
20
 a(9)      / parenthesis
20
 a[10]     / out of range return zero
0
@end example
@section Updating List Elements
Lists can be updated elementwise by  setting the indexed element to a required value.  There is also a syntax for updating many elements and that is found at @ref{amend}.

@example
 a:2*1+!10;a
2 4 6 8 10 12 14 16 18 20
 a[3]:80
 a
2 4 6 80 10 12 14 16 18 20
@end example

@section Functions Applied to Two Lists
This section will focus on functions (f) that operate on two lists (x and y).  As these are internal functions, examples will be shown with infix notation (x+y) but prefix notation (+[x;y]) would  also be possible.


@subsection Pairwise
These functions operate on list elements pairwise and thus requires that x and y are equal length.
@itemize
@item @t{x+y : Add}
@item @t{x-y : Subtract}
@item @t{x*y : Multiply}
@item @t{x%y : Divide}
@item @t{x&y : AND/Min}
@item @t{x|y : OR/Max}
@item @t{x>y : Greater Than}
@item @t{x<y : Less Than}
@item @t{x=y : Equals}
@item @t{x!y : Dictionary}
@item @t{x$y : Sumproduct}
@end itemize

@example
@ x:1+!5; y:10-2*!5
@ x
1 2 3 4 5
@ y
10 8 6 4 2
@ x+y
11 10 9 8 7
@ x-y
-9 -6 -3 0 3
@ x*y
10 16 18 16 10
@ x%y
0.1 0.25 0.5 1 2.5f
@ x&y
1 2 3 4 2
@ x|y
10 8 6 4 5
@ x>y
00001b
@ x<y
11100b
@ x=y
00010b
@ x!y
1|10
2| 8
3| 6
4| 4
5| 2
@ x$y / dot product JOHN: THIS IS NOT WORKING FOR ME.
70
@end example

@subsection Each Element of One List Compared to Entire Other List
These functions compare x[i] to y or x to y[i]. They are  not symmetric to their inputs, i.e. f[x;y] does not equal f[y;x];

@itemize
@item @t{x^y : Reshape all element in y by x}
@item @t{x#y : List all elements in x that appear in y}
@item @t{x?y : Indices of elements of y in x else return the length of x.}
@end itemize

@example
 x:0 2 5 10
 y:!20
 x^y
0 1                          
2 3 4                        
5 6 7 8 9                    
10 11 12 13 14 15 16 17 18 19

 x:2 8 20
 y:1 2 3 7 8 9
 x#y
2 8
 x?y
3 0 3 3 1 3
@end example

@subsection Each List Used Symmetrically
This is symmetric in its inputs f[x;y]=f[y;x] and the lists are not required to be equal length.

@itemize
@item @t{x_y : Values present in only one of the two lists}
@end itemize

@example
@ x:2 8 20
@ y:1 2 3 7 8 9
@ x_y
1 3 7 9
@end example


@node Dictionary
@chapter Dictionary
Dictionaries are a data type of key-value pairs typically used to retrieve the value by using the key.  In other computer languages they are also known as associative arrays and maps.  Keys should be unique to avoid lookup value confusion but uniqueness is not enforced.  The values in the dictionary can be single elements, lists, tables, or even other dictionaries.

Dictionaries in k9 are often used.  As an example from finance, market quotes and trade data are dictionaries of symbols (name keys) and market data (table values).  

@section Dictionary Creation @result{} x!y or [x;y]

Dictionaries are created by using the key symbol or square bracket notation and listing the keys (x) and values (y).  

@code{x!y}

@example
 d0:`a37!12; d0                          / key is `a37 and value is 12
a37|12

 d1:`pi`e`c!3.14 2.72 3e8;d1             / three keys `pi, `e, `c
pi|3.14 
e |2.72 
c |3e+08

 `a`b`c!(1 2 3;10 20 30;100 200 300 499) / values are lists
a|1 2 3      
b|10 20 30   
c|100 200 300 499
@end example

@code{[x:y]}

@example
 d0:[a37:12]
a37|12

 d1:[pi:3.14;e:2.72;c:3e8];d1
pi|3.14
e |2.72
c |3e+08

 [a:1 2 3;b:10 20 30;c:100 200 300]
a|1 2 3      
b|10 20 30   
c|100 200 300
@end example

Often one will need to modify the data while building the dictionary.  User defined functions can easily accomplish this task.

@example
 `x`sinX`cosX!@{(x;sin y;cos z)@} . 3#,0.1*(!62)
x   |0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 ..
sinX|0 0.09983342 0.1986693 0.2955202 0.3894183 0..
cosX|1 0.9950042 0.9800666 0.9553365 0.921061 0.8..

@end example

@section Dictionary Join @result{} x,y
This joins dictionaries together and the right or y dictionary will overwrite the left or x dictionary if common keys are present.

@example
 d1:`a`b`c!3 2 1;d1
a|3
b|2
c|1

 d2:`c`d`e!90 80 70;d2
c|90
d|80
e|70

 ^d1,d2 / ^ sort by key
a| 3
b| 2
c|90
d|80
e|70

 ^d2,d1 / ^ sort by key
a| 3
b| 2
c| 1
d|80
e|70
@end example

@section Dictionary Indexing @result{} x@@y

Dictionaries, like lists, can be key indexed in a number of ways.

@example
 x:`a`b`c!(1 2;3 4;5 6);x
a|1 2
b|3 4
c|5 6

x@@`a   / single index     
1 2

x@@`a`c / multiple index   
1 2
5 6

/ all these notations for indexing work (output not shown)
 x@@`b;  / at
 x(`b); / parenthesis
 x `b;  / space
 x[`b]; / square bracket
@end example

@section Dictionary Key @result{} !x
The keys from a dictionary are retreived by using the ! function.

@example
@ !d0
`pi`e`c
@ !d1
`time`temp
@ !d2
0 10 1
@end example

@section Dictionary Value @result{} x[]
The values from a dictionary are retrieved using bracket notation.

@example
 d0[]
3.14 2.72 3e+08
 d1[]
12:00 12:01 12:10
25.   25.1  25.6 

 d2[]
37.4 46.3 0.1
@end example

One could return a specific value by indexing into a specific location.  As an example, in order to query the first value of the values associated with the key temp from d1, one would convert d1 into values (a pair of lists), and index that by [1;0]. 

@example
@ d1
time|12:00 12:01 12:10
temp|25 25.1 25.6     

@ d1[]
12:00 12:01 12:10
25    25.1  25.6 

@ d1[][1]
25 25.1 25.6
@ d1[][1;0]
25.
@end example

@section Sorting a Dictionary by Key @result{} ^x

@example
@ d0
pi|3.14 
e |2.72 
c |3e+08

@ ^d0
c |3e+08
e |2.72 
pi|3.14 
@end example

@section Sorting a Dictionary by Value @result{} <x (>x)

@example
@ d0
pi|3.14 
e |2.72 
c |3e+08

@ <d0
e |2.72 
pi|3.14 
c |3e+08

@ >d0
c |3e+08
pi|3.14 
e |2.72 
@end example

@section Flipping a Dictionary into a Table @result{} +x
This command flips a dictionary into a table and will be covered in detail in the table chapter.

@example
 d1
time|12:00 12:01 12:10
temp|25 25.1 25.6     

 +d1
time  temp
----- ----
12:00 25  
12:01 25.1
12:10 25.6

 d1~+d1
0b
@end example

@section Functions that operate on each value in a dictionary
There are a number of simple functions on dictionaries that operate on their values.  If 'f' is a function then f applied to a dictionary returns a dictionary with the same keys and the values resulting from the application of 'f'.

@itemize
@item @t{-d : Negate}
@item @t{d + N : Add N to d}
@item @t{d - N : Subtract N from d}
@item @t{d * N : Multiple d by N}
@item @t{d % N : Divide d by N}
@item @t{|d : Reverse}
@item @t{<d : Sort Ascending}
@item @t{>d : Sort Descending}
@item @t{~d : Not d}
@item @t{&d : Given d:x!y output each x, y times, where y must be an integer}
@item @t{=d : Given d:x!y y!x}
@end itemize

Examples
@example
@ d2
@ 0|37.4
10|46.3
@ 1|0.1 

@ -d2
@ 0|-37.4
10|-46.3
@ 1|-0.1 

@ d2+3
@ 0|40.4
10|49.3
@ 1|3.1 

@ d2-1.7
@ 0|35.7
10|44.6
@ 1|-1.6

@ d2*10
@ 0|374
10|463
@ 1|1  

@ d2%100
@ 0|0.374
10|0.463
@ 1|0.001
@end example

@section Functions that return over values from a dictionary
There are functions on dictionaries that operate over the values.  Given function f applied to a dictionary d, f d returns one or more values  without the original keys.

@itemize
@item *d : First value
@end itemize
@example
@ d0
pi|3.14
e |2.72
c |3e+08

@ *d0
3.14
@end example

@node User Functions
@chapter User-defined Functions
User-defined functions are treated as verbs in k9, so can benefit from the adverbs.

Multi-line functions must be defined with an initial space on all lines except the first.  These can be loaded into memory by using the @ref{load,\l} command and then used by calling by name.

@example
Func @{[a;b]a+b@}
@end example

@section Function arguments
Functions default to arguments of x, y, and z for the first three parameters but one  can  explicitly spell out these or other argument names.  Given k9's terseness, many k9 programmers prefer short variable names. But this is a matter of taste.

@example
 f1:@{x+2*y@}         / implicit arguments x and y
 f1[2;10]
22

 f2:@{[x;y]x+2*y@}    / explicit
 f2[2;10]
22

 f3:@{[g;h]g+2*h@}    / explicit arguments other than x and y
 f3[2;10]
22

 f4:@{[please;dont]please+2*dont@} / longer argument names are possible
 f4[2;10]
22

 @@f1
`.
@end example

@section Function Defitions
Functions can have intermediate calcuations and local variables.  Function local variables do not affect the values of  global variables.

@example
 a:3;a
3

 f:@{a:12;x:sqrt x;x+a@}

 f 10
15.16228

a
3
@end example

@section Function Return
Function return the last value in the definition unless the definition ends with a semicolon in which case the function returns nothing.

@example
 f:@{x+2;@};f 10  / returns nothing because of final semi-colon

 f:@{x+2;27@};f 10  / returns the last value which is 27
27

 f:@{x+2@};f 10
12
@end example

@section Calling functions
Functions, like lists, can be called in a variety of ways.  Typically one uses square bracket notation when the function takes multiple argruments.  If a function is called with fewer than the required number of arguments then it will return a function that requires the remaining arguemnts.

@example
 f1:@{[x] x@}
 f2:@{[x;y](x;y)@}
 f3:@{[x;y;z](x;y;z)@}
 
 f1[`a]
`a

 f2[37;`a]
37
a 

 f3["hi";37;`a]
hi
37
a 

 f2[37]     
@{[x;y](x;y)@}[37]
 f2[;`a]
@{[x;y](x;y)@}[;`a]

 f1[`a]
`a
 f1 `a
`a
 f1@@`a
`a
@end example 

@section Anonymous functions
It's possible to define a function without naming it. If the function is to be used in just one place, this can make sense.

@example
 @{x+2*y@}[2;10]
22
@end example

@section Recursive functions
k9 allows one to define a function which calls itself.  Care should be taken to avoid an infinite loop.

@example
 f:@{$[x>1;x*f@@x-1;1]@};f 5
120
@end example

@section Chained functions
It may be necessary to define a function to call a function without specifying arguments.  Imagine this trivial case.

@example
 fa:@{!x@}
 fb:@{x+2@} fa
@{x+2@}
^
:rank
@end example

In order to succeed fa needs to have an @code{@@} in the definition of fb.  This is required because fb calls fa without specifying an argument for fa. So the argument for fb becomes the argument for fa so the net effect is 2 + !3.

@example
 fa:@{!x@}
 fb:@{x+2@} fa@@
 fb 3
2 3 4
@end example

@node Expression
@chapter Expression Evaluation
k9 has a compact way to evaluate an expression on data structures including dictionaries and tables.

@verbatim
Expr :a+b
@end verbatim

@section expr @result{} x :y
Evaluate expression(s) @code{y} on table or dictionary @code{x}.  The space between @code{x} and @code{:} is required otherwise it becomes @ref{set}, i.e., assignment.

@example
 d:`city!`London
 d :city
`London

 d :`Paris=city
0b

 d:`city!`London`Paris`Madrid
 d :`Paris=city
010b

 d:`a`b`c!(3 2 1;1 2 3;1 2 3);d
a|3 2 1
b|1 2 3
c|1 2 3

 d :a+b*c
4 6 10

t:+d;t
a b c
- - -
3 1 1
2 2 2
1 3 3

 t :(a+b*c)
4 6 10

 d:`a`b`c!(3 2 1;1 2 3;1 2 3);d
 d :(100*a;b+c)
300 200 100
2 4 6      
@end example

Reorder a table using column index and expresssions.

@example
 t:[[]x:`b`a`c;y:1 3 2];t
x y
- -
b 1
a 3
c 2

 t@@<t :y
x y
- -
b 1
c 2
a 3

 t@@<t`y
x y
- -
b 1
c 2
a 3
@end example

@node Named Functions
@chapter Named Functions
This chapter covers the built-in  named functions.  This includes some math (eg. sqrt but not +), wrapper (eg. count for #) and range (eg. within) functions.


rand has bin in within div mod bar rand cmb msum mavg
count first last sum min max *[avg var dev med ..]; key meta


@smallformat
@example
@ref{exp} @ref{log} @ref{sin} @ref{cos} @ref{sqr} @ref{sqrt} @ref{prm} @ref{freq} @ref{sums} @ref{deltas}
@ref{rand} @ref{has} @ref{bin} @ref{in} @ref{within} @ref{div} @ref{mod} @ref{bar} @ref{cmb} @ref{msum} @ref{mavg}
@ref{Hcount,count} @ref{Hfirst,first} @ref{Hlast,last} @ref{Hsum,sum} @ref{Hmin,min} @ref{Hmax,max}
@end example
@end smallformat

@anchor{exp}@section exp @result{} exp x
exp compute the exponent of x, i.e. e@sup{x}.

@example
@ exp 1
2.718282
@end example

@anchor{log}@section log @result{} log x
Log computes the natural log.

@example
@ log 10
2.302585
@end example

@anchor{sin}@section sin @result{} sin x
sin computes the sine of x where x is in radians.
@example
@ sin 0
0f
@ sin 3.1416%2
1.
@end example

@anchor{cos}@section cos @result{} cos x
cos computes the cosine of x where x is in radians.
@example
@ cos 0
1f
@ cos 3.1416%4
0.7071055
@end example

@anchor{sqr}@section sqr @result{} sqr x
Compute the square of x.

@example
@ sqr 2
4.0
@end example

@anchor{sqrt}@section sqrt @result{} sqrt x
Compute the square root of x.

@example
@ sqrt 2
1.414214
@end example

@anchor{prm}@section prm @result{} prm x
Write out all permutations of integers up x-1. Display them as columns.

@example
 prm 3
0 1 1 0 2 2
1 0 2 2 0 1
2 2 0 1 1 0
@end example

@anchor{freq}@section freq @result{} freq x
Compute the frequency of the items in list x.

@example
 freq "abzccdefeajfekjrlke"
a|2
b|1
c|2
d|1
e|4
f|2
j|2
k|2
l|1
r|1
z|1

 freq 1000 rand 10
0| 95
1|106
2| 84
3| 98
4|109
5|104
6| 94
7| 95
8|120
9| 95
@end example

@anchor{sums}@section sums @result{} sums x
Compute the running sum of list x.  Sames as @code{+\}.

@example
 sums !10
0 1 3 6 10 15 21 28 36 45
@end example

@anchor{deltas}@section deltas @result{} deltas x and x deltas y
Compute the difference between each element in list x and the previous value.  If delta is called with two parameters then x will be used as the first value to delta instead of the default 0.

@example
 deltas 1 5 10
1 4 5

 1 deltas 1 5 10
0 4 5
@end example

@anchor{rand}@section rand @result{} randx
Generate x random values using a uniform distribution from [0,1). @c or -x random values of a normal distribution (mean=0, standard deviation=1).

@example
 3 rand 1     / 3 uniform
0.1654719 0.172977 0.4808443
@end example

@anchor{has}@section has @result{} x has y
Determine whether vector x has element y. Simliar to @ref{in} but with the arguments reversed.

@example
 `a`b`c`a`b has `a
1b

`a`b`c`a`b has `d
0b

 `a`b`c`a`b has `a`b`x`y`z
11000b

 (1 2;4 5 6;7 9)has(1 2;8 9)
10b
@end example

@anchor{bin}@section bin @result{} x bin y
Given a sorted (increasing) list x, find the greatest index, i, where y>x[i].

@example
@ n:exp 0.01*!5;n
1 1.01005 1.020201 1.030455 1.040811
@ 1.025 bin n
2
@end example

@anchor{in}@section in @result{} x in y
Determine if x is in list y.  Similar to @ref{has} but arguments reversed.

@example
@ `b in `a`b`d`e
1b
@ `c in `a`b`d`e
0b
@end example

@anchor{within}@section within @result{} x within y
Test if x is equal to or greater than y[0] and less than y[1].

@example
 3 within 0 12
1b

0 within 0 12
1b

12 within 0 12
0b

23 within 0 12
0b
@end example

@anchor{div}@section div @result{} x div y
y divided by x using integer division, taking the floor of the result.  x and y must be integers.

@example
@ 2 div 7
3
@ 5 div 22
4
@end example

@anchor{mod}@section mod @result{} x mod y
The remainder after y divided by x using integer division.  x and y must be integers.

@example
@ 12 mod 27
3
@ 5 mod 22
2
@end example

@anchor{bar}@section bar @result{} x bar y
For each value in y determine the maximum multiple of x that is less than or equal to each y.

@example
@ 10 bar 9 10 11 19 20 21
0 10 10 10 20 20
@end example

@anchor{cmb}@section cmb @result{} x cmb y
Determine all x value combinations up to y. In this case these are ordered in ascending order from left to right.

@example
 3 cmb 5
2 3 4
1 3 4
1 2 4
1 2 3
0 3 4
0 2 4
0 2 3
0 1 4
0 1 3
0 1 2

 `a`b`c`d`e@@3 cmb 5
`c`d`e
`b`d`e
`b`c`e
`b`c`d
`a`d`e
`a`c`e
`a`c`d
`a`b`e
`a`b`d
`a`b`c
@end example

@anchor{msum}@section msum @result{} x msum y
Compute the length x  moving sum of list y.

@example
 3 msum !10
0 1 3 6 9 12 15 18 21 24
@end example


@anchor{mavg}@section mavg @result{} x mavg y
Compute the length x  moving average of list y.

@example
 3 mavg !10
0 0.3333333 1 2 3 4 5 6 7 8
@end example

@anchor{Hcount}@section count @result{} count x
Same as @ref{count}.

@example
 count 5 1 2
3
@end example

@anchor{Hfirst}@section first @result{} first x
Same as @ref{first}.

@example
 first 5 1 2
5
@end example

@anchor{Hlast}@section last @result{} last x
Retrieve the last element of list x.

@example
 last 5 1 2
2
@end example

@anchor{Hsum}@section sum @result{} sum x
Compute the sum of list x.  Same as @code{+/}.

@example
 sum 5 1 2
8
@end example
@anchor{Hmin}@section min @result{} min x
Retrieve the minimum element of list x.  Same as @code{|/}.

@example
 min 5 1 2
1
@end example

@anchor{Hmax}@section max @result{} max x
Retrieve the maximum element of list x.  Same as @code{&/}.

@example
 max 5 1 2
5
@end example

@anchor{topX}@section top @result{} top x
Return the index of the max value of list x.

@example
 top 3 13 15 1 17 0 -3
4

top "abzccdefeajfekjrlke"
2
@end example

@anchor{keyF}@section key @result{} x key y
Key table y with x. That is, the values in the x column become the key values.

@example
 `a key [[]a:`fa`fb;b:1 2]
a |b
--|-
fa|1
fb|2

 `a key [[]a:`fa`fb;b:((1 2 3); (4 5 6))]
a |b    
--|-----
fa|1 2 3
fb|4 5 6
@end example

@anchor{unkey}@section unkey @result{} unkey x
Remove key from table x.

@example
 unkey [[a:`x`y]b:1 2]
a b
- -
x 1
y 2
@end example

@anchor{meta}@section meta @result{} meta
Determine the types of the fields in a table.

@example
 meta [[]a:`x`y;b:1 2]
a|n
b|i
@end example

@node Knit Functions
@chapter Knit Functions
These functions modify lists and dictionaries given a list of indices and functions or values to replace.

@example
@@[r;i;f[;y]] @ref{amend}
.[r;i;f[;y]] @ref{dmend}
@end example

@anchor{amend}@section amend @result{} @@[r;i;f[;y]]
Replace the values in list / dictionary r at indices i with element f or function f and parameter y.  The original list is not modified.  Indices are rows for lists and keys for dictionaries.

@flushleft
@multitable {amend with function 2 param123} {function123} {2nd param123}
@item @b{action} @tab @b{f} @tab @b{y} 
@item @ref{amend1,amend with element} @tab element @tab n/a
@item @ref{amend2,amend with element/array} @tab : @tab element/list
@item @ref{amend3,amend with function 1 param} @tab function @tab n/a
@item @ref{amend4,amend with function 2 param} @tab function @tab 2nd param
@end multitable
@end flushleft

@anchor{amend1}
Amend to element.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 @@[r;0 3;29]      / change the first and fourth rows
29 
2 3
4 5
29 

 r               / r doesn't change
0 1
2 3
4 5
6  
@end example

@anchor{amend2}
Amend with element/array.  If using an array, then the @code{i} and @code{y} must be arrays of equal length.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 @@[r;1 2;:;(0;3 5)]
0 1
0  
3 5
6  
@end example

@anchor{amend3}
Amend with function f[r] at indices i.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 @@[r;1 2;sqrt]
0 1              
1.414214 1.732051
2.0 2.236068     
6

 d:[x:`a`b`c;y:9 4 1];d / dictionary example
x|`a`b`c
y|9 4 1 

 @@[d;`y;sqrt]
x|`a`b`c
y|3 2 1.
@end example

@anchor{amend4}
Amend with function f[r;y] at indices i.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 @@[r;1 2;*;10 100]
0 1    
20 30  
400 500
6      

 d:[x:`a`b`c;y:9 4 1];d / dictionary
x|`a`b`c
y|9 4 1 

 @@[d;`y;*;10]
x|`a`b`c  
y|90 40 10
@end example

@anchor{dmend}@section dmend @result{} .[r;i;f[;y]]
Similar to @ref{amend} but using @code{i} to fully index @code{r}.

@flushleft
@multitable {dmend with function 2 param123} {function123} {2nd param123}
@item @b{action} @tab @b{f} @tab @b{y} 
@item @ref{dmend1,dmend with element} @tab element @tab n/a
@c@item @ref{dmend2,dmend with element/array} @tab : @tab element/list
@item @ref{dmend3,dmend with function 1 param} @tab function @tab n/a
@item @ref{dmend4,dmend with function 2 param} @tab function @tab 2nd param
@end multitable
@end flushleft

@anchor{dmend1}
Dmend to element.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 .[r;0 1;12]       / modify the entry at [0;1]
0 12
2 3 
4 5 
6   
@end example

@anchor{dmend3}
Dmend with function f[r] at indices i.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 .[r;1 1;sqrt]
0 1         
2.0 1.732051
4 5         
6           
@end example

@anchor{dmend4}
Dmend with function f[r;y] at indices i.

@example
 r:(0 1;2 3;4 5;6);r
0 1
2 3
4 5
6  

 .[r;1 1;+;100]
0 1  
2 103
4 5  
6    
@end example

@node I/O
@chapter I/O and Interface
In order to support fast data analysis, k9 supports fast input and output (I/O).  If you have the habit of making tea while a huge csv file loads, you might have to opt to take a few sips from a glass of water instead.

k9 is also able to interface with other languages so one doesn't need to translate everything you've already written in those
other languages to k9.

@example
 I/O(*enterprise)
 0: @ref{r line,r}/@ref{w line,w} line
 1: @ref{r byte,r}/@ref{w byte,w} byte
*2: @ref{r data,r}/@ref{w data,w} data
*3: @ref{k-ipc set}    
*4: @ref{https get}
*5: @ref{ffi/py/js/..}

@ref{read json,`js?}@ref{write json,`js} d
@ref{read csv,`csv?}@ref{write csv,`csv} t
@end example

@section Example of Data I/O
Let's begin with a simple example to show how to read data from a csv file.  We'll generate a small table and save it with and without headers (wHeader.csv and woHeader.csv respectively).  Then we'll read it back in, both specifying types and with the csv reader.  Types are specifed by one letter and the full list can be found in @ref{Atom Types}.

@example
 t:[[]a:3 2 1;b:1. 2. 4.;c:`x`y`z];t / generate table
a b  c
- -- -
3 1. x
2 2. y
1 4. z

 "wHeader.csv"0:`csv t               / save with column headers
wHeader.csv

"woHeader.csv"0:1_`csv t             / save without col headers
woHeader.csv

`csv?0:"wHeader.csv"                 / default reader
a b  c
- -- -
3 1. x
2 2. y
1 4. z

 (",";"ifn")0:"wHeader.csv"          / separator and types
a b  c
- -- -
3 1. x
2 2. y
1 4. z

 (`e`f`g;",";"ifn")0:"woHeader.csv"  / names, separator and types
e f  g
- -- -
3 1. x
2 2. y
1 4. z
@end example

@anchor{read csv}@section read csv @result{} @math{`}csv?x
Convert x from csv format.  Works on lists and tables.

@example
 `csv?("a,b";"1,3.";"2,4.")
a b 
- --
1 3.
2 4.
@end example

@anchor{write csv}@section write csv @result{} @math{`}csv x
Convert x to csv format.  Works on lists and tables.

@example
 `csv [[]a:1 2;b:3. 4.]
a,b 
1,3.
2,4.
@end example

@anchor{read json}@section read json @result{} @math{`}js?x
Convert x from json format.  Works on lists and tables.

@example
 `js?("@{a:1,b:3.@}";"@{a:2,b:4.@}")
a b 
- --
1 3.
2 4.
@end example

@anchor{write json}@section write json @result{} @math{`}js x
Convert x to json format.  Works on lists and tables.

@example
 `js [[]a:1 2;b:3. 4.]
@{a:1,b:3.@}
@{a:2,b:4.@}
@end example

@anchor{read nv}@section read name value @result{} @math{`}nv?x
Convert x, a list of name:value pairs, to a dictionary.

@example
 `nv?("key1:value1";"key2:value2")
key1|value1
key2|value2
@end example

@anchor{w line}@section write line @result{} x 0:y
Output to x the list of strings in y.  y must be a list of strings.  If y is a single string then convert to list via @ref{list}.

@example
 ""0:("blue";"red")      / "" represents stdout
blue
red

 "file.txt" 0: ("blue"; "red") / write to file, one line per element

 "some.csv" 0:`csv [[]a:1 2;b:3. 4.]
"some.csv"
@end example

@anchor{r line}@section read line @result{} 0:x
Read from file x.

@example
 0:"some.csv"
a,b 
1,3.
2,4.
@end example

@anchor{w byte}@section write byte @result{} x 1:y
Output to file x the list of chars in y as bytes.

@example
 "some.txt"1:"0123ABab"
"some.txt"

t:1:"some.txt";t
48 49 50 51 65 66 97 98g

`c t
"0123ABab"
@end example

@anchor{r byte}@section read byte @result{} 1:x
Read from byte data from file x.  See @ref{w byte} for an example to write and then read byte data.

@anchor{r data}@section read data @result{} 2: x

Enterprise Only

Load file, eg.@: csv or from a (x 2: y) save.  For the latter, one can find a ``save then load'' example in the next section.

@example
 2:`t.csv
s    t        e p  z   
---- -------- - -- ----
AABL 09:30:00 D 11 4379
AABL 09:30:00 B 40 3950

@ 2:`r                / read from file
a          b          c          d          e         
---------- ---------- ---------- ---------- ----------
0.5366064  0.8250996  0.8978589  0.4895149  0.6811532 
0.1653467  0.05017282 0.4831432  0.4657975  0.4434603 
0.08842649 0.8885677  0.23108    0.3336785  0.6270692 
..

@end example

@anchor{w data}@section write data @result{} x 2: y

Enterprise only

Save to file x non-atomic data y (e.g., lists, dictionaries, or tables). 

This example saves 100 million 8-byte doubles to file.  The session is then closed and a fresh session reads in the file.  Both the write (420 ms) and compute statistics from the file  have impressive speeds (146 ms) given the file size (800 MB).

@example
 n:_1e8
 r:+`a`b`c`d`e!5^n rand 1.;r
 `r 2:r              / write to file 
@end example

Start new session.

@example
 \t r:2:`r;select avg a,sum b, max c, min d, sum e from r
148
@end example


@anchor{k-ipc set}@section k-ipc set @result{} 3:

Enterprise only

@anchor{https get}@section https get @result{} 4:

Enterprise only

@anchor{ffi/py/js/..}@section ffi/py/js/.. @result{} 5:

Enterprise only

Load shared library.

Contents of file 'a.c'
@example
int add1(int x)@{return 1+x;@}
int add2(int x)@{return 2+x;@}
int indx(int x[],int y)@{return x[y];@}
@end example

Compile into a shared library (done on macos here)
@example
% clang -dynamiclib -o a.so a.c
@end example

Load the shared library into the session.
@example
@ f:"./dev/a.so"5:@{add1:"i";add2:"i";indx:"Ii"@}
@ f[`add1] 12
13
@ f[`indx][12 13 14;2]
14
@end example

@node Tables
@chapter Tables
k9 has the ability to store data in a tabular format containing named columns and rows of information as tables.  If the data to be stored and queried is large, then you should use tables.  This chapter introduces the different types of data tables available in k9.  Table, Utable and Ntable are very similar and as you'll see in the @ref{kSQL} chapter are easy to query.  In the @ref{Benchmark} chapter, you'll see that tables are fast to save, read, and query.

@example
 @ref{table} t:[[]i:2 3;f:2.3 4]
@ref{Utable} u:[[x:..]y:..]
@ref{Ntable} n:`..![[]y:..]
@end example

@anchor{table}@section table
The table is the most basic of the three types.  A table consists of columns and rows of information where each column has a name.  Tables can be created in three different ways (1) specification via table format, (2) flipping a dictionary, or (3) reading in from a file.

@subsection Table format
Tables can be created with the table square bracket notation.

As an example, let's create a table with two columns named ``a'' and ``col2'' having three rows.  The syntax is to surround the definition with square brackets and then have a first element of empty square brackets. Following those brackets comes first column name, colon, and the list of values, then the second column, and continuing for all the columns. For keyed tables, the initial square brackets will contain key column names as we will discuss later.  

@example
 [[] a:1 20 3; col2: 3.6 4.8 0.1]
a  col2
-- ----
 1 3.6 
20 4.8 
 3 0.1

 [[] a:1; col2:3.6]   / will error :class as lists required
[[] a:1; col2:3.6]

:class

 [[] a:,1; col2:,3.6] / using list will succeed
[[]a:,1;col2:,3.6]
@end example

@subsection Dictionary format
Tables can also be created by flipping a dictionary into a table.  

@example
 +`a`col2!(1 20 3;  3.6 4.8 0.1)      / +columnnames!(values)
a  col2
-- ----
 1 3.6 
20 4.8 
 3 0.1 
@end example

@subsection File import
Tables can also be created by reading in a file.

t.csv
@verbatim
a, col2
1, 3.6
20, 4.8
3, 0.1
@end verbatim

Use load file @code{2:x} which returns a table.

@example
 2:`t.csv
a   col2
-- -----
 1  3.6 
20  4.8 
 3  0.1 
@end example

@anchor{Utable}@section Utable
Utable (or key table) is a table where some of the columns are keyed. The combination of those columns  should not have two rows with the same values. This must be enforced by the application.

@example
 [[d:2020.09.08 2020.09.09 2020.09.10]p:140 139 150]
d         |p  
----------|---
2020.09.08|140
2020.09.09|139
2020.09.10|150

 `d^ [[]d:2020.09.08 2020.09.09 2020.09.10;p:140 139 150]
d         |p  
----------|---
2020.09.08|140
2020.09.09|139
2020.09.10|150
@end example

@anchor{Ntable}@section Ntable
A Ntable is a collection of tables stored in a dictionary where the keys are symbols and the values are tables. Thus, it has both the data and schema of a set of tables, much like a data dictionary in a conventional relational database. Below is an example where the keys are symbols and the values are
end-of-day prices.

@example
@ x1:+`d`p!(2020.09.08 2020.09.09 2020.09.10;140 139 150)
@ x2:+`d`p!(2020.09.08 2020.09.10;202 208)
@ eod:`AB`ZY!(x1;x2)  / This is an Ntable. 
@ eod`AB
d          p  
---------- ---
2020.09.08 140
2020.09.09 139
2020.09.10 150
@end example

@node kSQL
@chapter kSQL
kSQL is a powerful query language for tables.  It has similarities to ANSI SQL but additional features to make it easier to work with ordered data, such as time series data.

@example
Database
@ref{select}[@ref{C}]@ref{A} from T @ref{where B}; @ref{update} C from T where B; @ref{delete} from T where B
x,y      / @ref{insert}, @ref{upsert}, @ref{union}, equi-and-asof @ref{leftjoin}
x+y      / equi-and-asof outerjoin (e.g. combine markets through time)
x#y      / take/intersect innerjoin (x_y for drop/difference)
@end example

@section Queries

@anchor{select}@subsection select
There a number of ways to return a complete table with kSQL.  You can use the table name, a kSQL query without columns, or a fully specified query with columns.

@example
 n:5;t:[[]x:!n;y:sin !n]
 t
x y         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025

 select from t
x y         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025

 select x,y from t
x y         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025
@end example

@anchor{A}@subsection A
A is the list of fields to return from the select query.  If A is missing then all fields will be returned.  A can create new column names.  

@example
 n:5;t:[[]x:!n;y:sin !n];t
x y         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025

 select from t
x y         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025

 select x from t
x
-
0
1
2
3
4

 select y,x from t    / reorder columns
y          x
---------- -
0.         0
0.841471   1
0.9092974  2
0.14112    3
-0.7568025 4

 select x,z:y from t  / create new column z
x z         
- ----------
0 0.        
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025
@end example

@anchor{C}@subsection C
kSQL also has a way to group rows using @code{C}.  The result is a Utable where the key is determined by the grouping clause.

@example
 n:5;t:[[]x:!n;y:sin !n]
 select[x>2]sum y from t / select sum y by x>2 from t
x|y         
-|----------
0|1.750768  
1|-0.6156825
@end example

@anchor{where B}@subsection where B
kSQL makes it easy to build up a where clause to filter down the table.  B is the list of constraints.

@example
 n:5;t:[[]x:!n;y:sin !n]
 select from t where x>0
x y         
- ----------
1 0.841471  
2 0.9092974 
3 0.14112   
4 -0.7568025

select from t where (x>0) & y within 0 .9
x y       
- --------
1 0.841471
3 0.14112 
@end example

@subsection Query with By and Where

@example
 n:5;t:[[]x:!n;y:sin !n]
 select[x>2]sum y from t@&t :y>0 / select sum y by x>2 from t where y>0
x|y       
-|--------
0|1.750768
1|0.14112 
@end example

@anchor{update}@subsection update
update allows one to modify values without specifying all the fields that pass through.  update is also used to add new columns in a table.  update does not, by itself, save the modifications to the table. If you want to preserve those modifications, use assignment.

@example
 t:[[]x:`a`b`c;y:1 2 3];t
x y
- -
a 1
b 2
c 3

 update y+18 from t
x y 
- --
a 19
b 20
c 21

 update z:y+18 from t
x y z 
- - --
a 1 19
b 2 20
c 3 21

 t:update z:y+18 from t; / save the updates into table t
 t                       / Now t has the updated values.
x y z 
- - --
a 1 19
b 2 20
c 3 21
@end example

@anchor{delete}@subsection delete
Delete rows from a table that satisfy one or more conditions.  Currently not working.

@example
 t:[[]x:`a`b`c;y:1 2 1];t
x y
- -
a 1
b 2
c 1

 delete from t where y>1
!value

 delete from t where x=`c,y=1
!nyi
@end example 

@section Joins
k9 has a number of methods to join tables together which are described below.  In this section t, t1 and t2 represent tables and k, k1 and k2 represent Utables.

@multitable {leftjoin123 leftjoin} {leftjoin 123}
@item @b{join} @tab @b{syntax}
@item @ref{union} @tab t1,t2
@item @ref{leftjoin} @tab t,k
@item @ref{outer} @tab k1,k2
@item @ref{asof} @tab t,k
@item @ref{asof+} @tab k1+k2
@end multitable

@anchor{union}@subsection union join @result{} t1,t2
Union join table t1 with table t2.  The tables should have the same columns and the join results in a table with t2 appended to t1.  If the tables do not have the same columns then return t1.

@example
@ t1:[[]s:`a`b;p:1 2;q:3 4]
@ t2:[[]s:`b`c;p:11 12;q:21 22]
@ t1
s p q
- - -
a 1 3
b 2 4

@ t2
s p  q 
- -- --
b 11 21
c 12 22

@ t1,t2
s p  q 
- -- --
a  1  3
b  2  4
b 11 21
c 12 22
@end example

@anchor{leftjoin}@subsection leftjoin @result{} t,k
leftjoin table t with Utable k.  Result includes all rows from t and the values from table k having the same key values.
If a row of t has key values not found in k, then the t values are shown and 0 for the columns coming from k.

@example
 t:[[]s:`a`b`c;p:1 2 3;q:7 8 9]
 k:[[s:`a`b`x`y`z]q:101 102 103 104 105;r:51 52 53 54 55]
 t
s p q
- - -
a 1 7
b 2 8
c 3 9

 k
s|q   r 
-|--- --
a|101 51
b|102 52
x|103 53
y|104 54
z|105 55

 / t.s includes the value `c. Because k.s does not include c,
 / the last row shows a 0 under the r column (which comes from k).
 t,k       
s p q   r 
- - --- --
a 1 101 51
b 2 102 52
c 3   9  0
@end example

@anchor{outer}@subsection outer join @result{} k1,k2
Outer join Utable k1 with key Utable k2. 

@example
@ k1:[[s:`a`b]p:1 2;q:3 4]
@ k2:[[s:`b`c]p:9 8;q:7 6]
@ k1
s|p q
-|- -
a|1 3
b|2 4

@ k2
s|p q
-|- -
b|9 7
c|8 6

@ k1,k2
s|p q
-|- -
a|1 3
b|9 7
c|8 6
@end example

@anchor{asof}@subsection asof join @result{} t,k
Asof joins each row rt of table t to a row rk in Utable k (keyed by time) provided rk has the maximum time value of any row in k while obeying the constraint that the time value in rt >= the time value of rk. Intuitively, rk should be the row in k that is most up-to-date with respect to rt. 

@example
 t:[[]t:09:30+5*!5;p:100+!5];t
t     p  
----- ---
09:30 100
09:35 101
09:40 102
09:45 103
09:50 104

 k:[[t:09:32 09:41 09:45]q:50 51 52];k
t    |q 
-----|--
09:32|50
09:41|51
09:45|52

 / Notice below the t row at 09:45 is linked with the k row at 09:45.
 / The k row at 09:41 is not linked with any t row.
 / By contrast, both the 09:35 and the 09:40 rows of t
 / are linked to the 09:32 row of k.
 t,k      
          
t     p   q 
----- --- --
09:30 100  0
09:35 101 50
09:40 102 50
09:45 103 52
09:50 104 52
@end example

Scaling this up to a bigger set of tables one can see the performance of k9 on joins.

@example
 N:_1e8;T:[[]t:N rand `t 0;q:N rand 100];5#T
t            q 
------------ --
00:00:00.001 44
00:00:00.002 46
00:00:00.002 48
00:00:00.003 35
00:00:00.003 43

 n:_1e5;K:[[t:n rand `t 0]p:n rand 100];5#K
t           |p 
------------|--
00:00:00.481|54
00:00:00.961|63
00:00:01.094|67
00:00:01.479|16
00:00:01.917|58

 \t T,K
222
@end example

@anchor{asof+}@subsection asof+ join @result{} k1+k2
Asof+ joins  allows one to aggregate over markets to find the total available at a given time.  The Utables need to be specified with @code{`a}. The effect is to merge the two key fields (the field t in this case) and for each row rk1 from table k1, add the non-key field (bs in this case) from rk1 to the bs field of the most recent row in k2 whose t value is less than or equal to the t value in rk1. And symmetrically for each row of table k2.

@example
 k1:`a [[t:09:30+5*!5]bs:100*1 2 3 2 1];k1
t    |bs 
-----|---
09:30|100
09:35|200
09:40|300
09:45|200
09:50|100

 k2:`a [[t:09:32 09:41 09:45]bs:1 2 3];k2
t    |bs
-----|--
09:32| 1
09:41| 2
09:45| 3

 k1+k2
t    |bs 
-----|---
09:30|100
09:32|101
09:35|201
09:40|301
09:41|302
09:45|203
09:50|103
@end example

@section Insert and Upsert
One can add data to tables via insert or upsert.  The difference between the two is that insert adds data to a table while upsert on some key x will replace the values if x is present in the target table or insert x with its associated value otherwise. 

@anchor{insert}@subsection insert @result{} t,d
Insert dictionary d into table t.
@example
 t:[[]c1:`a`b`a;c2:1 2 7];t
c1 c2
-- --
a   1
b   2
a   7

 t,`c1`c2!(`a;12)
c1 c2
-- --
a   1
b   2
a   7
a  12

 t,`c1`c2!(`c;12)
c1 c2
-- --
a   1
b   2
a   7
c  12
@end example

@anchor{upsert}@subsection upsert @result{} k,d
Insert dictionary d into Utable k.
@example
 k:[[c1:`a`b`c]c2:1 2 7];k
c1|c2
--|--
a | 1
b | 2
c | 7

 k,`c1`c2!(`a;12)
c1|c2
--|--
a |12
b | 2
c | 7

 k,`c1`c2!(`b;12)
c1|c2
--|--
a | 1
b |12
c | 7

 k,`c1`c2!(`d;12)
c1|c2
--|--
a | 1
b | 2
c | 7
d |12
@end example

@node System
@chapter System
k9 comes with a few system functions and measurement commands.  The commands allow you to load a script, change the working directory, measure execution times and memory usage, and list defined variables.

@example
System
\l a.k @ref{load}
\t:n x @ref{timing}
\u:n
\v     @ref{variables}
\w     @ref{memory}
\cd x  @ref{cd}
@end example

@anchor{load}@section load @result{} \l a.k
Load a text file of k9 commands.  The file name must end in .k.
@example
@ \l func.k
\l func.k
@ \l func.k7  / will error as not .k
:nyi
@end example

@anchor{timing}@section timing @result{} \t x or \t:n x
List time elapsed in milliseconds in evaluting x.  If n is supply then repeat x, n times.

@example
 \t ^(_10e6)rand _1e8     / sort 10 million numbers
227

 \t:10 ^(_10e6)rand _1e8  / perform 10 times the sort
2027
@end example

@anchor{variables}@section variables @result{} \v
List variables
@example
a:1;b:2;c:3
@ \v
[v:`a`b`c]
@end example

@anchor{memory}@section memory @result{} \w
List memory usage
@example
@ \w
0
@ r:(`i$10e6)rand 10
@ \w
2097158
@end example

@anchor{cd}@section cd @result{} \cd x
Change directory (cd) into x

@example
@ \cd scripts
@end example

@node Control Flow
@chapter Control Flow
Though looping statements are not necessary in k9, if-then-else statements are sometimes useful.

@verbatim
$[b;t;f] cond
@end verbatim

@anchor{cond}@section cond @result{} $[b;t;f]
If b is non zero then x else y.  x and y are not required to be of the same type.

@example
 $[3>2;`a;`b]
`a

 $[2>3;`a;`b]
`b

 $[37;12;10]
12

 $[1b;`a`b!(1 2;3 4);`n]
a|1 2
b|3 4

 $[1b;a:3;b:2]
3
 a
3
 b   / is not set as the f case not evaluated
!value
@end example

@node Temporal Functions
@chapter Temporal Functions
k9 has functions (within @code{.z}) to get the current date and time to various degrees of precision.  There are also functions to retrieve partial date and time using dot notation.

@verbatim
date 2001.01.01   .z.d
time 12:34:56.789 .z.t
@end verbatim

@section .z.[dm] date
These functions retrieve the date as day (d) or month (m) precision.

@example
 .z.d
2020.12.13

 .z.m
2020.12.
@end example

@section .z.[hrstuv] time
These functions retrieve the time at hour (h), minute (r), second (s), millisecond (t), microsecond (u), or nanosecond (v) precision.

@example
 .z.h
11
 .z.r
11:25
 .z.s
11:25:16
 .z.t
11:25:16.842
 .z.u
11:25:17.491362
 .z.v
11:25:18.186360064
@end example

One could use the current time commands to measure run time but typically this is done via @code{\t}

@example
 t1:.z.v;(_2e8)rand 1.;t2:.z.v;t2-t1
00:00:00.609207008

\t (_2e8)rand 1.
610
@end example

@section Temporal dot functions
These functions use dot notation to retrieve partial date and times.

@example
 now:.z.v;now
11:27:18.049558016
 now.h
11
 now.r
11:27
 now.s
11:27:18
 now.t
11:27:18.049
 now.u
11:27:18.049558
 now.v
11:27:18.049558016
@end example

@node Errors
@chapter Errors
Given the terse syntax of k9, it likely won't be a surprise  that  error messages are also rather short.  The errors are listed on the help page and described in more detail below.

@example
error: @ref{class} @ref{rank} @ref{length}
@ref{_type,type} @ref{domain} @ref{limit}
stack @ref{eparse,parse} @ref{_value,value}
@end example

@anchor{class}@section :class
Calling a function on mismatched types.
@example
@ 3+`b
:class
@end example

@anchor{rank}@section :rank
Calling a function with too many parameters.
@example
@ @{x+y@}[1;2;3]
@{x+y@}[1;2;3]
^
:rank
@end example

@anchor{length}@section :length
Operations on unequal length lists that require equal length.
@example
@ (1 2 3)+(4 5)
:length
@end example

@anchor{_type}@section :type
Calling a function with an unsupported variable type.
@example
`a+`b
@  ^
:type
@end example

@anchor{domain}@section :domain
Exhausted the number of input values
@example
@ -12?10   / only 10 unique value exist
:domain
@end example

@anchor{limit}@section :limit
Exceeded a limit above the software maximum, eg. writing a single file above 1GB.
@example
@ n:_100e6;d:+`x`y!(!n;n rand 1.);`d 2:d
n:_100e6;d:+`x`y!(!n;n rand 1.);`d 2:d

:limit
@end example

@anchor{nyi}@section :nyi
Running code that is not yet implemented.  This may come from running code in this document with a different version of k9.

2020.05.31 (c) shakti

@example
@ =+`a`b!(1 2;1 3)
a b| 
- -|-
1 1|0
2 3|1
@end example

Aug  6 2020 16GB (c) shakti

@example
@ =+`a`b!(1 2;1 3)
=+`a`b!(1 2;1 3)
^
:nyi
@end example

@anchor{eparse}@section :parse
Syntax is wrong.  This may be due to mismatched parentheses or  brackets, e.g., (), @{@}, [], "".
@example
@ @{37 . "hello"
:parse
@end example

@anchor{_value}@section :value
Undefined variable is used.
@example
@ g    / assuming 'g' has not be defining in this session
:value
@end example
@node Examples
@chapter Examples
@c [JOHN: THIS SHOULD GO AFTER YOU EXPLAIN THE LANGUAGE. AGAIN, IT'S TOO SCARY AS OF NOW.]
This chapter presents an example from finance, as this is one of the primary application domains for k.  For those not familiar with this field, here is a short introduction.

@section A Tiny Introduction to Financial Market Data
Financial market data generally are stored as prices (often call quotes) and trades.  At a minimum, prices will include time (t), price to buy (b for bid) and price to sell (a for ask).  Trades will include at a minimum time (t) and trade price (p).  In normal markets there are many more prices than trades.  (Additionally, the data normally includes the name of the security (s) and the exchange (x) from which the data comes.)  

Let's use k9 to generate a set of random prices.

@example
 n:10
 T:^10:00+`t n rand 36e5 / sort randomly generated times
 B:100++\-1+n rand 3     / generate bids near 100, equivalent to: 100 + (+\((-1)+n rand 3))
 A:B+1+n rand 2          / generates asks 1 or 2 higher
 q:+`t`b`a!(T;B;A);q     / build table t and then display
t            b   a  
------------ --- ---
10:01:48.464 100 102
10:23:12.033 100 102
10:30:00.432 101 102
10:34:00.383 101 103
10:34:36.839 101 102
10:42:59.230 100 102
10:46:50.478 100 102
10:52:42.189  99 100
10:55:52.208  99 101
10:59:06.262  98  99
@end example

Here you see that at 10:42:59.230 the prices update to 100 and 102.  The price one could sell is 100 and the price to buy is 102.  You might think that 100 seems a bit high so sell there.  Later at 10:59:06.262 you might have thought the prices look low and then buy at 99.  Here's the trade table for those two transactions.

@example
 t:+`t`p!(10:43:00.230 10:59:07.262:;100 99);t
t            p  
------------ ---
10:43:00.230 100
10:59:07.262  99
@end example

You'll note that the times didn't line up, because it apparently took you a second to decide to trade.  Because of this delay, you'll often have to look back at the previous prices to join trade (t) and quote (q) data.

Now that you've learned enough finance to understand the data, let's scale up to larger problems to see the power of k9.


@section Data Manipulation
Generate a table of random data and compute basic statistics quickly.  The data here includes time (t), security (s), and price delta (d).  This table takes about 4 GB and 3.3 seconds on a relatively new consumer laptop.

@example
@ n:_100e6                         / set n to 100 million 
@ t:@{09:00:00.000+x rand 10:00:00.000@}  /  x random times between 9:00 and 19:00 (7 pm)
@ s:@{x rand `a`b`c`d`e@}                 / x random symbols from `a`b`c`d`e
@ m:0,(|m),365378984,m:271810244 42800467 2636454 62769 572 2;  / start m with 6 numbers, then regenerate m with 0, |m, 365378984, m
@ d:@{(-6+!13)@@(+\m)bin x rand _1e9@}  / (i) Take the running sum of m. 
@                / (ii) find the binary search index values of the x random numbers drawn up to 1e9 using bin
@                / (iii) use those indexes on the array of integers from -6 to +6 inclusive
@ \t q:+`t`s`d!(t[n];s[n];d[n])    / build table and measure time in ms
3391
@end example 

As this point one might want to check start and stop times, see if the symbol distribution is actually random and look at the distribution of the price deltas.

@example
 select ti:min t, tf:max t from q / min and max time values
ti|09:00:00.000
tf|18:59:59.999

 select c: count s by s from q          / count each symbol
s|c       
-|--------
a|20003490
b|19997344
c|19998874
d|20000640
e|19999652

 select c: count d by d from q          / check normal dist (2s to run)
d |c       
--|--------
-6|1       
-5|55      
-4|6226    
-3|263801  
-2|4280721 
-1|27179734
 0|36531595
 1|27188092
 2|4279872 
 3|263610  
 4|6245    
 5|48

 select gain:sum d by s from q    / profit (or loss) over each symbol
s|gain 
-|-----
a|  872
b| 2765
c| 2668
d| 2171
e|-2354

 select loss:min +\d by s from q  / worst loss over the period
s|loss 
-|-----
a|-1803
b| -846
c|-2732
d|-2101
e|-2903
@end example

@section Understanding Code Examples
In the shakti mailing list there are a number of code examples that can be used to learn best practices.  In order to make sense of other people's codes, one needs to be able to efficiently understand  k9 language expressions.  Here is an example of how one goes about this process.

@example
ss:@{*@{
      o:o@@&(-1+(#y)+*x@@1)<o:1_x@@1;
      $[0<#x@@1;((x@@0),*x@@1;o);x]@}[;y]/:(();&(x@@(!#x)+\!#y)~\y)
      @}
@end example

This function finds a substring in a string.

@verbatim
 000000000011111111112222222222333333
 012345678901234567890123456789012345
"Find the +++ needle in + the ++ text"
@end verbatim

Here one would expect to find ``++'' at 9 and 29.

@example
@ ss["Find the +++ needle in + the ++ text";"++"]
9 29
@end example

In order to determine how this function works let's strip out the details...

@example
ss:@{
    *@{
      o:o@@&(-1+(#y)+*x@@1)<o:1_x@@1; / set o 
      $[0<#x@@1;((x@@0),*x@@1;o);x]   / if x then y else z
      @}
  [;y]/:(();&(x@@(!#x)+\!#y)~\y)    / use value for inner function
  @}
 
@end example

Given that k9 evaluates right to left, let's start with the rightmost code fragment.

@example
@ (();&(x@@(!#x)+\!#y)~\y)          / a list (null;value)
@end example

And now let's focus on the value in the list.

@example
@ &(x@@(!#x)+\!#y)~\y
@end example

In order to easily check our understanding, we can wrap this in a function and call the function with the parameters shown above.  In order to step through, we can start with the inner parenthesis and build up the code until it is complete.

@example
@ @{!#x@}["Find the +++ needle in + the ++ text";"++"]
@{!#x@}["Find the +++ needle in + the ++ text";"++"]
^
:rank
@end example

This won't work as one cannot call a function with two arguments and then use only one.  In order to get around this, we will insert code for the second argument but not use it.

@example
 @{y;#x@}["Find the +++ needle in + the ++ text";"++"]
36
 @{y;!#x@}["Find the +++ needle in + the ++ text";"++"]
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ..
@end example

As might have been guessed @code{#x} counts the number of charcters in the first argument and then @code{!#x} generates a list of integers from 0 to n-1.

@example
@ @{(!#x)+\!#y@}["Find the +++ needle in + the ++ text";"++"]  
 0  1
 1  2
 2  3
 3  4
 4  5
 5  6
 6  7
 7  8
 8  9
 9 10
10 11
11 12
12 13
13 14
14 15
15 16
16 17
17 18
18 19
19 20
20 21
..
@end example

Here the code takes each integer from the previous calculation and then adds an integer list as long as the second argument to each value.  In order to verify this,  you could write something similar and ensure the output what you predicted.

@example
@ @{(!x)+\!y@}[6;4]
0 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
5 6 7 8
@end example

Now using the matrix above the code indices as the first argument and pull substrings that match the length of the search string.

@example
@ @{x@@(!#x)+\!#y@}["Find the +++ needle in + the ++ text";"++"]
Fi
in
nd
d 
 t
th
he
e 
 +
++
++
+ 
 n
ne
ee
ed
dl
le
e 
 i
in
..
@end example

At this point one can compare the search substring in this list of substrings to find a match.

@example
@ @{(x@@(!#x)+\!#y)~\y@}["Find the +++ needle in + the ++ text";"++"]
000000000110000000000000000001000000b
@end example

And then one can use the where function, @code{&}, to determine the index of the matches.

@example
@ @{&(x@@(!#x)+\!#y)~\y@}["Find the +++ needle in + the ++ text";"++"]
9 10 29
@end example

@node Benchmark
@chapter Benchmark
Shakti is a fast data analysis language  and clear benchmarks illustrate this.  The Shakti website has a number of files for such purpose, b.k and taxi.k amongst others.  

@section b.k

@verbatim
T:{09:30:00+_6.5*3600*(!x)%x}
P:{10+x rand 90};Z:{1000+x rand 9000};E:rand[;"ABCD"]

/m:2;n:6
m:7000;n:5600000;
S:(-m)rand `4;N:|1+_n*{x%+/x:exp 15*(!x)%x}m

t:S!{+`t`e`p`z!(T;E;P;Z)@'x}'N
q:S!{+`t`e`b!(T;E;P)@'x}'6*N

a:*A:100#S

\t  {select max p by e from x}'t A
\t  {select sum z by `o t from x}'t A
\t:10 {select last b from x}'q A
\t:10 select from t[a],`t^q a where p<b
\

C:M:rand[;"ABCDEFGHIJ"]
trade(sym time exchange price size cond)
quote(sym time exchange bid bz ask az mode)

                Q1      Q2      Q3      Q4  ETL   RAM   DSK
k                1       9       9       1                                            
postg        71000    1500    1900     INF  200   1.5   4.0
spark       340000    7400    8400     INF  160  50.0   2.4
mongo        89000    1700    5800     INF  900   9.0  10.0   

960 billion quotes (S has 170 billion. QQQ has 6 billion.)
 48 billion trades (S has 12 billion. QQQ has 80 million.)
@end verbatim

@subsection T
T is a function which generates a uniform list of times from 09:30 to 16:00.

@example
@ T:@{09:30:00+_6.5*3600*(!x)%x@}
@ T[13]           / 13 times with equal timesteps over [start;end)
^09:30:00 10:00:00 10:30:00 11:00:00 11:30:00 .. 15:00:00 15:30:00
@ rand1_-':T[10000]  / determine the unique timesteps
?00:00:02 00:00:03
@end example

@subsection P, Z, E
P is a function to generate values from 10 to 100 (price).  Z is a function to generate values from 100 to 1000 (size).  E is a function to generate values A, B, C, or D (exchange).

@example
@ P[10]
78 37 56 85 40 68 88 50 41 78
@ Z[10]
4820 2926 1117 4700 9872 3274 6503 6123 9451 2234
@ E[10]
"AADCBCCCBC"
@end example

@subsection m, n, S, N
m is the number of symbols.  n is the number of trades.  S is a list of symbol names.  N is a list of  numbers in decreasing order which sum approximately to n.  

@example
@ 4#S
`EEFD`IOHJ`MEJO`DHNK
@ 4#N
11988 11962 11936 11911
@ +/N
5604390
@end example

@subsection t
t is an Ntable of trades.  The fields are time (t), exchange (e), price (p), and size (z).  The number of trades is set by n.

Pulling one random table from t and showing 10 random rows.  

@example
@ 10 rand*t@@1 rand S
t        e p  z   
-------- - -- ----
14:37:53 D 73 4397
11:43:25 B 20 2070
10:21:18 A 53 6190
13:26:03 C 33 7446
14:07:06 B 13 2209
15:08:41 D 12 4779
14:27:37 A 11 6432
11:22:53 D 92 9965
11:12:37 A 14 5255
12:24:28 A 48 3634
@end example

@subsection q
q is a Ntable of quotes.  The fields are time (t), exchange (e), and bid (b).  The number of quotes is set to 6*n.

@example
@ 10 rand*q@@1 rand S
t        e b 
-------- - --
11:31:12 A 80
14:08:40 C 63
14:05:07 D 12
11:31:43 A 56
12:44:19 A 45
10:13:21 A 71
15:19:08 A 74
13:42:20 D 43
11:31:41 D 66
14:41:38 A 63
@end example

@subsection a, A
a is the first symbol of S.  A consists of the first 100 symbols of S.

@example
@ a
`PKEM
@end example

@subsection Max price by exchange
The query takes 100 tables from the trade Ntable and computes the max price by exchange.

@example
@ *@{select max p by e from x@}'t A
e|p 
-|--
A|99
B|99
C|99
D|99
@ \t  @{select max p by e from x@}'t A
22
@end example

@subsection Compute sum of trade size by hour.
This query takes 100 tables from the trade Ntable and computes the sum of trade size done by hour.

@example
@ *@{select sum z by `o t from x@}'t A
t |z       
--|--------
09| 4885972
10|10178053
11|10255045
12|10243846
13|10071057
14|10203428
15|10176102
@ \t  @{select sum z by `o t from x@}'t A
27
@end example

@subsection Compute last bid by symbol
This query takes the 100 tables from the quote Ntable and returns the last bid.

@example
@ 3 rand@{select last b from x@}'q A
b 
--
18
98
85

@ \t:10 @{select last b from x@}'q A
2
@end example

@subsection Find trades below the bid
This query operates on one symbol from the q and t Ntables, i.e. a single quote and trade table.  The quote table is joined to the trade table giving the current bid on each trade.

@example
@ 4 rand select from t[a],`t^q a where p<b
t        e p  z    b 
-------- - -- ---- --
13:54:35 B 94 1345 96
11:59:52 C 26 1917 89
10:00:44 C 40 9046 81
10:59:39 A 25 5591 72
@ \t:10 select from t[a],`t^q a where p<b
3
@end example

@section taxi
The taxi data analysis problem has become well known given the ease of acquiring the data and the size of it.  It's well written up  @uref{https://toddwschneider.com/posts/analyzing-1-1-billion-nyc-taxi-and-uber-trips-with-a-vengeance/,here} with a benchmark summary @uref{https://tech.marksblogg.com/benchmarks.html,here}.  Shakti has a benchmark script to generate simulated taxi data in order to check performance.

@smallformat
@verbatiminclude taxi.k
@end smallformat

@subsection g
Function to generate a table of random data to represent taxi company (@b{t} either yellow `y or green `g),  paid fare (@b{p} 0-9), distance travelled (@b{d} 0-99) and address (@b{a} 0-100.).

@example
 g:@{[[]t:x rand`y`g;p:x rand 9;d:x rand 100;a:x rand 100.]@}
 g 10
t p d  a       
- - -- --------
y 7 38 50.67771
g 5 34 38.51022
y 6 40 9.654263
y 6  5 98.91451
g 7 47 44.40432
g 0 64 66.07784
y 0 99 25.84292
y 5 46 46.87825
y 5 66 81.61647
g 0 10 7.946983
@end example

@subsection x
x is an Ntable containing 2500 tables, keyed on day.  Each individual table contains 44,000 rows therefore x has 110 million rows in total.

@example
 x:d!g':44000+&#d:2009.01.01+!2500  /110 million example
 x
2009.01.01|[[]t:`y`y`g`y`g`g`y`y`g`g`g`g`g`y`y`y`y`g`g`g..
2009.01.02|[[]t:`y`g`g`g`y`g`y`g`y`g`g`g`g`y`g`y`g`y`g`y..
2009.01.03|[[]t:`y`g`g`g`y`g`y`g`y`g`g`g`g`y`g`y`g`y`g`y..
2009.01.04|[[]t:`y`g`g`g`y`g`y`g`y`g`g`g`g`y`g`y`g`y`g`y..
..
@end example

@subsection 2009.01.04
Let's work with a single table to understand the queries and limit it to 5 rows.

@example
 q:5#x 2009.01.04;q
t p d  a       
- - -- --------
y 3 41 54.5307 
g 6 70 70.4241 
g 1 63 81.46645
g 7 36 43.12615
y 1 43 23.50114
@end example

Now let's count the number of rows by field t.  Looking at the data above you should expect 2 yellow (y) taxi trips and 3 green (g) taxi trips.

@example
 select[t]count from q
t|n
-|-
g|3
y|2
@end example

We can also sum the paid fare (p) by taxi company (t).

@example
 select[t]sum p from q
t|p
-|--
g|14
y| 4
@end example

Now if we want to compute the same over all the data we need to run the kSQL query over each table.  We'll do this on parallel threads (@ref{eachp}) to speed it up.

@example
 @{select[t]count from x@}':x
2009.01.01|[[t:`g`y]n:21968 22032]
2009.01.02|[[t:`g`y]n:21962 22038]
2009.01.03|[[t:`g`y]n:21962 22038]
2009.01.04|[[t:`g`y]n:21962 22038]
@end example

and then sum over all days.

@example
 sum@{select[t]count from x@}':x
t|n       
-|--------
g|55010927
y|54989073
@end example

Running the command with the timer will allow us to measure how long it takes to sum over the 110 million examples.

@example
 \t sum@{select[t]count from x@}':x
1077
@end example

@node Conclusion
@chapter Conclusion

I expect you are pleasantly surprised by the speed of k9 and by the fact that it all fits in 134,152 bytes!  (For comparison the ls program weighs in at 51,888 bytes and can't even change directory.)

If you're frustrated by the syntax or terse errors, then you're not alone.  Many have had the same problems, but persevered, and finally came away a power user able to squeeze information from data faster than previously imagined.

Eventually, you'll realize that this manual isn't needed and it's all here...

@smallformat
@verbatiminclude k.d
@end smallformat


@c @node Index
@c @unnumbered Index


@c @printindex cp

@bye


@c At this point I expect you reached the same conclusion I did, this manual (not produced by Shakti) isn't that good.  Feel free to ask for corrections or improvements in any area that would make it better.
@c 
@c On a more serious note, 
